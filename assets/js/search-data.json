{
  
    
        "post0": {
            "title": "Découverte du langage SQL",
            "content": "Dans ce TP jous allons découvrir le langage SQL (Structured Query Language) qui est le langage utilisé pour effectuer des requêtes sur une base de données relationnelles. Nous apprendrons lors de ce TP à . créer des tables avec les attributs que l&#39;on souhaite | insérer des enregistrements | faire des requêtes sur la base pour extraire des informations | . Contrairement aux apparences, nbous n&#39;utiliserons pas Python dans ce classeur, mais directement SQL grâce à l&#39;extension ipython-sql qu&#39;il faut activer en validant la cellule suivante : . %load_ext sql . En cas d&#39;erreurs lors du chargement de l&#39;extension, vous pouvez tenter de réinstaller les paquets nécessaires via les commandes . pip install jupyter-sql pip install ipython-sql sudo apt install python3-sql . puis relancer jupyter. . Cr&#233;er la base de donn&#233;es . Nous allons commencer par créer une base vide dans laquelle nous allons travailler : . %sql sqlite:///livres_db . La base s&#39;appelle livres_db et est au format sqlite qui est un gestionnaire de base de données relationnelles léger et facile à prendre en main. . Les données seront inscrites dans le fichier livres_db qui vient d&#39;être créé à côté de ce classeur et que vous pourrez télécharger quand vous aurez fini ce TP. . L&#39;objectif est de peupler cette base de données avec la base livres que l&#39;on a étudié lors de la découverte du modèle relationnel. Cette base sera constituée de 3 tables : . AUTEURS | LIVRES | NOTES | . Cr&#233;er une table . Il est temps de commencer à peupler notre base de données. Nous allons commencer par la table AUTEURS. Nous allons donc saisir notre première requête : . %%sql CREATE TABLE &quot;AUTEURS&quot; ( &quot;id&quot; INTEGER PRIMARY KEY, &quot;nom&quot; TEXT, &quot;prenom&quot; TEXT, &quot;langue&quot; TEXT, &quot;annee_nai&quot; INTEGER ); . Quelques explications : . Pour commencer, dans jupyter lorsque nous voudront taper une commande SQL et non du la,gage python, nous inscrirons en première ligne de cellule la commande magique %%sql. N&#39;oubliez jamais de commencer toutes vos cellules ainsi car sinon, la commande sera interprétée par python qui ne connait pas le langage SQL et provoquera une erreur. . La première requête SQL que nous allons apprendre est la requête CREATE TABLE . on insique le nom de la table à créer | entre parenthèse on liste les attributs à mettre ainsi que leur type. | une requête se termine toujours par ; | . Nous avons deux types différents dans notre base de données : . le type TEXT pour tout ce qui est chaîne de caractères | le type INTEGER pour les entiers | . L&#39;attribut id est la clé primaire de la table. C&#39;est un entier qui commence à 1 et qui sera automatiquement incrémenté au fur à mesure que l&#39;on insère des données dans la table. C&#39;est en indiquant PRIMARY KEY après le type dans la déclaration de l&#39;attribut id que sqlite se comporte ainsi. . Ins&#233;rer des enregistrements dans la table . Maintenant que nous avons une table vide, il nous faut la remplir avec les données sur les auteurs. Nous utiliserons pour cela la requête INSERT. Voici son utilisation : . %%sql INSERT INTO AUTEURS (nom, prenom, langue, annee_nai) VALUES (&quot;Orwell&quot;, &quot;George&quot;, &quot;Anglais&quot;, 1903), (&quot;Herbert&quot;, &quot;Frank&quot;, &quot;Anglais&quot;, 1920), (&quot;Asimov&quot;, &quot;Isaac&quot;, &quot;Anglais&quot;, 1920), (&quot;Huxley&quot;, &quot;Aldous&quot;, &quot;Anglais&quot;, 1894), (&quot;Bradbury&quot;, &quot;Ray&quot;, &quot;Anglais&quot;, 1920), (&quot;K. Dick&quot;, &quot;Philip&quot;, &quot;Anglais&quot;, 1928), (&quot;Barjavel&quot;, &quot;René&quot;, &quot;Français&quot;, 1911), (&quot;Boulle&quot;, &quot;Pierre&quot;, &quot;Français&quot;, 1912), (&quot;Van Vogt&quot;, &quot;Alfred Elton&quot;, &quot;Anglais&quot;, 1912), (&quot;Verne&quot;, &quot;Jules&quot;, &quot;Français&quot;, 1828); . Quelques explications : . La requête INSERT s&#39;utilise ainsi : . INSERT INTO ##TABLE## (## attributs dont on donne les valeurs##) VALUES (## enregistrement 1 ##), ... (## enregistrement n ##); . On peut refaire une autre requête INSERT à la suite si on qouhaite ajouter encore des données au bout de la table. . Vous remarquez que l&#39;on ne donne pas de valeur pour l&#39;attribut id. C&#39;est parce qu&#39;on l&#39;a déclaré en PRIMARY KEY. Il est donc automatiquement géré par sqlite. Nous verrons cela en lisant le cpontenu complet de la table. . On est pas obligé de préciser tous les attributs. id est un exemple particulier, mais il est possible d&#39;ommetre d&#39;autres attributs. Ils seront alors affectés d&#39;une valeur nulle. . A l&#39;issue de la requête, sqlite nous informe que 10 lignes ont été créées. . Lire le contenu d&#39;une table . Nous allons à présent utiliser une requête SELECT afin de récupérer le contenu de la table. Ces requêtes peuvent être très sophistiquées comme on va le voir en fin de TP. Pour le moment, nous nous contenterons de la forme la plus simple : . %%sql SELECT * FROM AUTEURS; . Vous voyez donc appraître le contenbu de la table. Vous constatez que la clé primaire id a bien été générée correctement. . Il est possible de stoquer le résultat de cette requête dans une variable pour l&#39;exploiter plus facilement dans jupyter? Voici comment procéder en modifiant légèrement la première ligne : . resultat = %sql SELECT * FROM AUTEURS; . Vous voyez au passage la syntaxe concise permettant de récupérer le résultat d&#39;une requête dans une variable. Cette variable résultat est exploitable dans ce classeur, y compris par python !! . resultat . print(resultat) . resultat[2] . On a donc ici le meilleur des deux mondes : des requêtes SQL et une base de données pour stocker efficacement les données, le langage python pour traiter ces données grâce à des algorithmes faciles à écrire. . A vous de jouer . Notre base n&#39;est pas encore complète : il nous reste à créer les tables LIVRES et NOTES qui doivent refléter le contenu suivant : . titre nom prenom annee_nai langue ann_publi note . 1984 | Orwell | George | 1903 | Anglais | 1949 | 10 | . Dune | Herbert | Frank | 1920 | Anglais | 1965 | 8 | . Fondation | Asimov | Isaac | 1920 | Anglais | 1951 | 9 | . Le meilleur des mondes | Huxley | Aldous | 1894 | Anglais | 1931 | 7 | . Fahrenheit 451 | Bradbury | Ray | 1920 | Anglais | 1953 | 7 | . Ubik | K. Dick | Philip | 1928 | Anglais | 1969 | 9 | . Chroniques martiennes | Bradbury | Ray | 1920 | Anglais | 1950 | 8 | . La nuit des temps | Barjavel | René | 1911 | Français | 1968 | 7 | . Blade Runner | K. Dick | Philip | 1928 | Anglais | 1968 | 8 | . Les Robots | Asimov | Isaac | 1920 | Anglais | 1950 | 9 | . La Planète des singes | Boulle | Pierre | 1912 | Français | 1963 | 8 | . Ravage | Barjavel | René | 1911 | Français | 1943 | 8 | . Le Maître du Haut Château | K. Dick | Philip | 1928 | Anglais | 1962 | 8 | . Le monde des A | Van Vogt | Alfred Elton | 1912 | Anglais | 1945 | 7 | . La Fin de l’éternité | Asimov | Isaac | 1920 | Anglais | 1955 | 8 | . De la Terre à la Lune | Verne | Jules | 1828 | Français | 1865 | 10 | . La table LIVRES . La table LIVRES devra avoir la structure décrite dans l&#39;extrait suivant : . id titre id_auteur ann_publi . ... | ... | ... | ... | . 8 | La nuit des temps | 7 | 1968 | . ... | ... | ... | ... | . l&#39;année de publication est de type INTEGER | id désigne bien sûr la clé primaire | id_auteur est une clé externe faisant référence à l&#39;auteur. | dans l&#39;extrait, la clé id_auteur vaut 7. L&#39;auteur de La nuit des temps est donc Barjavel | on ne renseigne pas la langue ou l&#39;année de naissance de l&#39;auteur car ces informations sont déjà présentes dans la table AUTEURS. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table LIVRES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, &#39;1984&#39;, 1, 1949) in resultat . La table NOTES . Terminons avec la table NOTES. Celle-ci devra avoir la structure décrite dans l&#39;extrait suivant : . id id_livre note . ... | ... | ... | . 7 | 7 | 8 | . ... | ... | ... | . la note est un entier | id désigne bien sûr la clé primaire | id_livre est une clé externe faisant référence au livre évalué. | dans l&#39;extrait, la clé id_livre vaut 7 : il s&#39;agit des Chroniques martiennes qui a eu la note 8. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table NOTES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, 1, 10) in resultat . Notre base de données est à présent complète. Nous allons voir à présent comment faire des requêtes plus élaborées, en particulier en mettant en place des filtres et des tris. . Aller plus loin avec SELECT . Filtre dans une requete SELECT . Supposons que l&#39;on veuille lister seulement les noms et prénoms des auteurs nés avant 1900, voici comment procéder : . %sql SELECT nom, prenom from AUTEURS WHERE annee_nai &lt; 1900; . Compter le nombre de r&#233;ponses d&#39;une requ&#234;te SELECT . Combien y a t-il d&#39;auteurs nés entre 1900 et 1915 ? . nbr = %sql SELECT COUNT(*) from AUTEURS WHERE annee_nai &gt;= 1900 AND annee_nai&lt;=1915; print(nbr) print(&quot;récupérer juste le nombre : &quot;, nbr[0][0]) . S&#233;lectionner des &#233;l&#233;ments distincts . Je m&#39;intéresse au différentes langues des auteurs. Si je fais la requête : . %sql SELECT langue from AUTEURS . cette requête affiche plein de doublons. On peut les enlever grâce à l&#39;utilisation du mot clé DISTINCT. . %sql SELECT DISTINCT langue from AUTEURS . Trier les r&#233;ponses . Nous allons lister tous les auteurs par ordre croissant d&#39;année de naissance . %sql SELECT * from AUTEURS ORDER BY annee_nai; . et par ordre décroissant, on ajoute DESC à la fin de la requête . %sql SELECT * from AUTEURS ORDER BY annee_nai DESC; . A vous de jouer . Donner la liste de tous les titres des livres écrits entre 1920 et 1950. | Combien y en a t-il ? | # Utilisez cette cellule en brouillon pour vos requetes . # Utiliser la syntaxe courte # reponse_i = %sql VOTRE REQUETE pour i=1 ou i=2 # YOUR CODE HERE raise NotImplementedError() . # Vérification des réponses assert reponse_1[3][0] == &#39;Les Robots&#39; assert reponse_2[0][0] == 6 . Il est temps de voir comment réunir les différentes tables afin d&#39;obtenir en un seul tableau les informations souhaitées. . Jointure des tables . Nous voulons récupérer la liste des titres des livres avec le nom de leur auteur. Il faut pour cela piocher les informations dans deux tables différentes en utilisant l&#39;attribut id_auteur comme clé de jointure. . %sql SELECT titre, nom FROM LIVRES JOIN AUTEURS ON LIVRES.id_auteur = AUTEURS.id; . Dans l&#39;exemple ci-dessus, nous avons JOIN LIVRES à AUTEURS en utilisant la clé externe LIVRES.id_auteur comme étant la clé primaire de la table AUTEURS. . A vous de jouer . récupérer dans la variable reponse_1 une liste dont les attributs sont titre, note et ann_publi dans cet ordre. | récupérer dans la variable reponse_2 une liste dont les attributs sont titre, prenom, nom et ann_publi mais triée par ordre de note décroissant. | récupérer dans la variable reponse_3 une liste dont les attributs sont titre, prenom, nom et ann_publi mais dont la note est au moins 9. | # Donner les réponses dans les variables reponse_i en utilisant la syntaxe courte # reponse_i = %sql SELECT blablabla # YOUR CODE HERE raise NotImplementedError() . # Utilisez cette cellule en brouillon pour vos requetes . assert reponse_1[0] == (&#39;1984&#39;,10,1949) assert reponse_2[0] == (&#39;1984&#39;,&quot;George&quot;,&quot;Orwell&quot;,1949) . Mise a jour, effacement : UPDATE et DELETE . Les requêtes UPDATE et DELETE fonctionnent sur le même modèle que les requêtes SELECT. Attention, on a vite fait d&#39;effacer toutes ses données si on ne configure pas bien sa requête. Une bonne habitude à prendre est de tester d&#39;abord ses critères à l&#39;aide d&#39;un SELECT. . Observez les exemples ci-dessous : . %%sql SELECT id FROM AUTEURS WHERE nom=&#39;Verne&#39; . %%sql UPDATE AUTEURS SET nom=&quot;Ze Djoule&quot; WHERE id=10 ; SELECT * FROM AUTEURS ; . %%sql DELETE FROM AUTEURS WHERE id=10; SELECT * FROM AUTEURS; . A vous de jouer . Réinsérez l&#39;auteur Jules Verne ! | Modifiez les notes afin de mettre 10 à chaque note égale ou inférieure à 8 | Supprimez tous les livres écrits au 19e sciecle | # YOUR CODE HERE raise NotImplementedError() . # Vérification de la présence de Jules res = %sql SELECT COUNT(*) FROM AUTEURS WHERE nom=&quot;Verne&quot; assert res[0][0] == 1 # Vérification de l&#39;absence de notes &lt;=8 res = %sql SELECT COUNT(*) FROM NOTES WHERE note &lt;= 8 assert res[0][0] == 0 # Vérification de l&#39;absence de livres du 19e res = %sql SELECT COUNT(*) FROM LIVRES WHERE ann_publi &lt;= 1900 assert res[0][0] == 0 . Attention &#224; la coh&#233;rence des donn&#233;es . Dans une base de données relationnelle il faut être vigilant lors de la suppression d&#39;enregistrements : en effet la suppression d&#39;en enregistement entraîne la suppression de sa clé primaire qui peut être utilisée en tant que clé externe dans une autre table. Cela entraîne la corruption des données. . Il existe en SQL des moyens pour se prémunir de ce type de problèmes mais cela dépasse le cadre de ce cours. .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/22/nsi_t_SQL.html",
            "relUrl": "/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/22/nsi_t_SQL.html",
            "date": " • Apr 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Découverte du langage SQL",
            "content": "Dans ce TP jous allons découvrir le langage SQL (Structured Query Language) qui est le langage utilisé pour effectuer des requêtes sur une base de données relationnelles. Nous apprendrons lors de ce TP à . créer des tables avec les attributs que l&#39;on souhaite | insérer des enregistrements | faire des requêtes sur la base pour extraire des informations | . Contrairement aux apparences, nbous n&#39;utiliserons pas Python dans ce classeur, mais directement SQL grâce à l&#39;extension ipython-sql qu&#39;il faut activer en validant la cellule suivante : . %load_ext sql . En cas d&#39;erreurs lors du chargement de l&#39;extension, vous pouvez tenter de réinstaller les paquets nécessaires via les commandes . pip install jupyter-sql pip install ipython-sql sudo apt install python3-sql . puis relancer jupyter. . Cr&#233;er la base de donn&#233;es . Nous allons commencer par créer une base vide dans laquelle nous allons travailler : . %sql sqlite:///livres_db . La base s&#39;appelle livres_db et est au format sqlite qui est un gestionnaire de base de données relationnelles léger et facile à prendre en main. . Les données seront inscrites dans le fichier livres_db qui vient d&#39;être créé à côté de ce classeur et que vous pourrez télécharger quand vous aurez fini ce TP. . L&#39;objectif est de peupler cette base de données avec la base livres que l&#39;on a étudié lors de la découverte du modèle relationnel. Cette base sera constituée de 3 tables : . AUTEURS | LIVRES | NOTES | . Cr&#233;er une table . Il est temps de commencer à peupler notre base de données. Nous allons commencer par la table AUTEURS. Nous allons donc saisir notre première requête : . %%sql CREATE TABLE &quot;AUTEURS&quot; ( &quot;id&quot; INTEGER PRIMARY KEY, &quot;nom&quot; TEXT, &quot;prenom&quot; TEXT, &quot;langue&quot; TEXT, &quot;annee_nai&quot; INTEGER ); . Quelques explications : . Pour commencer, dans jupyter lorsque nous voudront taper une commande SQL et non du la,gage python, nous inscrirons en première ligne de cellule la commande magique %%sql. N&#39;oubliez jamais de commencer toutes vos cellules ainsi car sinon, la commande sera interprétée par python qui ne connait pas le langage SQL et provoquera une erreur. . La première requête SQL que nous allons apprendre est la requête CREATE TABLE . on insique le nom de la table à créer | entre parenthèse on liste les attributs à mettre ainsi que leur type. | une requête se termine toujours par ; | . Nous avons deux types différents dans notre base de données : . le type TEXT pour tout ce qui est chaîne de caractères | le type INTEGER pour les entiers | . L&#39;attribut id est la clé primaire de la table. C&#39;est un entier qui commence à 1 et qui sera automatiquement incrémenté au fur à mesure que l&#39;on insère des données dans la table. C&#39;est en indiquant PRIMARY KEY après le type dans la déclaration de l&#39;attribut id que sqlite se comporte ainsi. . Ins&#233;rer des enregistrements dans la table . Maintenant que nous avons une table vide, il nous faut la remplir avec les données sur les auteurs. Nous utiliserons pour cela la requête INSERT. Voici son utilisation : . %%sql INSERT INTO AUTEURS (nom, prenom, langue, annee_nai) VALUES (&quot;Orwell&quot;, &quot;George&quot;, &quot;Anglais&quot;, 1903), (&quot;Herbert&quot;, &quot;Frank&quot;, &quot;Anglais&quot;, 1920), (&quot;Asimov&quot;, &quot;Isaac&quot;, &quot;Anglais&quot;, 1920), (&quot;Huxley&quot;, &quot;Aldous&quot;, &quot;Anglais&quot;, 1894), (&quot;Bradbury&quot;, &quot;Ray&quot;, &quot;Anglais&quot;, 1920), (&quot;K. Dick&quot;, &quot;Philip&quot;, &quot;Anglais&quot;, 1928), (&quot;Barjavel&quot;, &quot;René&quot;, &quot;Français&quot;, 1911), (&quot;Boulle&quot;, &quot;Pierre&quot;, &quot;Français&quot;, 1912), (&quot;Van Vogt&quot;, &quot;Alfred Elton&quot;, &quot;Anglais&quot;, 1912), (&quot;Verne&quot;, &quot;Jules&quot;, &quot;Français&quot;, 1828); . Quelques explications : . La requête INSERT s&#39;utilise ainsi : . INSERT INTO ##TABLE## (## attributs dont on donne les valeurs##) VALUES (## enregistrement 1 ##), ... (## enregistrement n ##); . On peut refaire une autre requête INSERT à la suite si on qouhaite ajouter encore des données au bout de la table. . Vous remarquez que l&#39;on ne donne pas de valeur pour l&#39;attribut id. C&#39;est parce qu&#39;on l&#39;a déclaré en PRIMARY KEY. Il est donc automatiquement géré par sqlite. Nous verrons cela en lisant le cpontenu complet de la table. . On est pas obligé de préciser tous les attributs. id est un exemple particulier, mais il est possible d&#39;ommetre d&#39;autres attributs. Ils seront alors affectés d&#39;une valeur nulle. . A l&#39;issue de la requête, sqlite nous informe que 10 lignes ont été créées. . Lire le contenu d&#39;une table . Nous allons à présent utiliser une requête SELECT afin de récupérer le contenu de la table. Ces requêtes peuvent être très sophistiquées comme on va le voir en fin de TP. Pour le moment, nous nous contenterons de la forme la plus simple : . %%sql SELECT * FROM AUTEURS; . Vous voyez donc appraître le contenbu de la table. Vous constatez que la clé primaire id a bien été générée correctement. . Il est possible de stoquer le résultat de cette requête dans une variable pour l&#39;exploiter plus facilement dans jupyter? Voici comment procéder en modifiant légèrement la première ligne : . resultat = %sql SELECT * FROM AUTEURS; . Vous voyez au passage la syntaxe concise permettant de récupérer le résultat d&#39;une requête dans une variable. Cette variable résultat est exploitable dans ce classeur, y compris par python !! . resultat . print(resultat) . resultat[2] . On a donc ici le meilleur des deux mondes : des requêtes SQL et une base de données pour stocker efficacement les données, le langage python pour traiter ces données grâce à des algorithmes faciles à écrire. . A vous de jouer . Notre base n&#39;est pas encore complète : il nous reste à créer les tables LIVRES et NOTES qui doivent refléter le contenu suivant : . titre nom prenom annee_nai langue ann_publi note . 1984 | Orwell | George | 1903 | Anglais | 1949 | 10 | . Dune | Herbert | Frank | 1920 | Anglais | 1965 | 8 | . Fondation | Asimov | Isaac | 1920 | Anglais | 1951 | 9 | . Le meilleur des mondes | Huxley | Aldous | 1894 | Anglais | 1931 | 7 | . Fahrenheit 451 | Bradbury | Ray | 1920 | Anglais | 1953 | 7 | . Ubik | K. Dick | Philip | 1928 | Anglais | 1969 | 9 | . Chroniques martiennes | Bradbury | Ray | 1920 | Anglais | 1950 | 8 | . La nuit des temps | Barjavel | René | 1911 | Français | 1968 | 7 | . Blade Runner | K. Dick | Philip | 1928 | Anglais | 1968 | 8 | . Les Robots | Asimov | Isaac | 1920 | Anglais | 1950 | 9 | . La Planète des singes | Boulle | Pierre | 1912 | Français | 1963 | 8 | . Ravage | Barjavel | René | 1911 | Français | 1943 | 8 | . Le Maître du Haut Château | K. Dick | Philip | 1928 | Anglais | 1962 | 8 | . Le monde des A | Van Vogt | Alfred Elton | 1912 | Anglais | 1945 | 7 | . La Fin de l’éternité | Asimov | Isaac | 1920 | Anglais | 1955 | 8 | . De la Terre à la Lune | Verne | Jules | 1828 | Français | 1865 | 10 | . La table LIVRES . La table LIVRES devra avoir la structure décrite dans l&#39;extrait suivant : . id titre id_auteur ann_publi . ... | ... | ... | ... | . 8 | La nuit des temps | 7 | 1968 | . ... | ... | ... | ... | . l&#39;année de publication est de type INTEGER | id désigne bien sûr la clé primaire | id_auteur est une clé externe faisant référence à l&#39;auteur. | dans l&#39;extrait, la clé id_auteur vaut 7. L&#39;auteur de La nuit des temps est donc Barjavel | on ne renseigne pas la langue ou l&#39;année de naissance de l&#39;auteur car ces informations sont déjà présentes dans la table AUTEURS. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table LIVRES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, &#39;1984&#39;, 1, 1949) in resultat . La table NOTES . Terminons avec la table NOTES. Celle-ci devra avoir la structure décrite dans l&#39;extrait suivant : . id id_livre note . ... | ... | ... | . 7 | 7 | 8 | . ... | ... | ... | . la note est un entier | id désigne bien sûr la clé primaire | id_livre est une clé externe faisant référence au livre évalué. | dans l&#39;extrait, la clé id_livre vaut 7 : il s&#39;agit des Chroniques martiennes qui a eu la note 8. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table NOTES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, 1, 10) in resultat . Notre base de données est à présent complète. Nous allons voir à présent comment faire des requêtes plus élaborées, en particulier en mettant en place des filtres et des tris. . Aller plus loin avec SELECT . Filtre dans une requete SELECT . Supposons que l&#39;on veuille lister seulement les noms et prénoms des auteurs nés avant 1900, voici comment procéder : . %sql SELECT nom, prenom from AUTEURS WHERE annee_nai &lt; 1900; . Compter le nombre de r&#233;ponses d&#39;une requ&#234;te SELECT . Combien y a t-il d&#39;auteurs nés entre 1900 et 1915 ? . nbr = %sql SELECT COUNT(*) from AUTEURS WHERE annee_nai &gt;= 1900 AND annee_nai&lt;=1915; print(nbr) print(&quot;récupérer juste le nombre : &quot;, nbr[0][0]) . S&#233;lectionner des &#233;l&#233;ments distincts . Je m&#39;intéresse au différentes langues des auteurs. Si je fais la requête : . %sql SELECT langue from AUTEURS . cette requête affiche plein de doublons. On peut les enlever grâce à l&#39;utilisation du mot clé DISTINCT. . %sql SELECT DISTINCT langue from AUTEURS . Trier les r&#233;ponses . Nous allons lister tous les auteurs par ordre croissant d&#39;année de naissance . %sql SELECT * from AUTEURS ORDER BY annee_nai; . et par ordre décroissant, on ajoute DESC à la fin de la requête . %sql SELECT * from AUTEURS ORDER BY annee_nai DESC; . A vous de jouer . Donner la liste de tous les titres des livres écrits entre 1920 et 1950. | Combien y en a t-il ? | # Utilisez cette cellule en brouillon pour vos requetes . # Utiliser la syntaxe courte # reponse_i = %sql VOTRE REQUETE pour i=1 ou i=2 # YOUR CODE HERE raise NotImplementedError() . # Vérification des réponses assert reponse_1[3][0] == &#39;Les Robots&#39; assert reponse_2[0][0] == 6 . Il est temps de voir comment réunir les différentes tables afin d&#39;obtenir en un seul tableau les informations souhaitées. . Jointure des tables . Nous voulons récupérer la liste des titres des livres avec le nom de leur auteur. Il faut pour cela piocher les informations dans deux tables différentes en utilisant l&#39;attribut id_auteur comme clé de jointure. . %sql SELECT titre, nom FROM LIVRES JOIN AUTEURS ON LIVRES.id_auteur = AUTEURS.id; . Dans l&#39;exemple ci-dessus, nous avons JOIN LIVRES à AUTEURS en utilisant la clé externe LIVRES.id_auteur comme étant la clé primaire de la table AUTEURS. . A vous de jouer . récupérer dans la variable reponse_1 une liste dont les attributs sont titre, note et ann_publi dans cet ordre. | récupérer dans la variable reponse_2 une liste dont les attributs sont titre, prenom, nom et ann_publi mais triée par ordre de note décroissant. | récupérer dans la variable reponse_3 une liste dont les attributs sont titre, prenom, nom et ann_publi mais dont la note est au moins 9. | # Donner les réponses dans les variables reponse_i en utilisant la syntaxe courte # reponse_i = %sql SELECT blablabla # YOUR CODE HERE raise NotImplementedError() . # Utilisez cette cellule en brouillon pour vos requetes . assert reponse_1[0] == (&#39;1984&#39;,10,1949) assert reponse_2[0] == (&#39;1984&#39;,&quot;George&quot;,&quot;Orwell&quot;,1949) . Mise a jour, effacement : UPDATE et DELETE . Les requêtes UPDATE et DELETE fonctionnent sur le même modèle que les requêtes SELECT. Attention, on a vite fait d&#39;effacer toutes ses données si on ne configure pas bien sa requête. Une bonne habitude à prendre est de tester d&#39;abord ses critères à l&#39;aide d&#39;un SELECT. . Observez les exemples ci-dessous : . %%sql SELECT id FROM AUTEURS WHERE nom=&#39;Verne&#39; . %%sql UPDATE AUTEURS SET nom=&quot;Ze Djoule&quot; WHERE id=10 ; SELECT * FROM AUTEURS ; . %%sql DELETE FROM AUTEURS WHERE id=10; SELECT * FROM AUTEURS; . A vous de jouer . Réinsérez l&#39;auteur Jules Verne ! | Modifiez les notes afin de mettre 10 à chaque note égale ou inférieure à 8 | Supprimez tous les livres écrits au 19e sciecle | # YOUR CODE HERE raise NotImplementedError() . # Vérification de la présence de Jules res = %sql SELECT COUNT(*) FROM AUTEURS WHERE nom=&quot;Verne&quot; assert res[0][0] == 1 # Vérification de l&#39;absence de notes &lt;=8 res = %sql SELECT COUNT(*) FROM NOTES WHERE note &lt;= 8 assert res[0][0] == 0 # Vérification de l&#39;absence de livres du 19e res = %sql SELECT COUNT(*) FROM LIVRES WHERE ann_publi &lt;= 1900 assert res[0][0] == 0 . Attention &#224; la coh&#233;rence des donn&#233;es . Dans une base de données relationnelle il faut être vigilant lors de la suppression d&#39;enregistrements : en effet la suppression d&#39;en enregistement entraîne la suppression de sa clé primaire qui peut être utilisée en tant que clé externe dans une autre table. Cela entraîne la corruption des données. . Il existe en SQL des moyens pour se prémunir de ce type de problèmes mais cela dépasse le cadre de ce cours. .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/21/_nsi_t_SQL.html",
            "relUrl": "/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/21/_nsi_t_SQL.html",
            "date": " • Apr 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Découverte du langage SQL",
            "content": "Dans ce TP jous allons découvrir le langage SQL (Structured Query Language) qui est le langage utilisé pour effectuer des requêtes sur une base de données relationnelles. Nous apprendrons lors de ce TP à . créer des tables avec les attributs que l&#39;on souhaite | insérer des enregistrements | faire des requêtes sur la base pour extraire des informations | . Contrairement aux apparences, nbous n&#39;utiliserons pas Python dans ce classeur, mais directement SQL grâce à l&#39;extension ipython-sql qu&#39;il faut activer en validant la cellule suivante : . %load_ext sql . En cas d&#39;erreurs lors du chargement de l&#39;extension, vous pouvez tenter de réinstaller les paquets nécessaires via les commandes . pip install jupyter-sql pip install ipython-sql sudo apt install python3-sql . puis relancer jupyter. . Cr&#233;er la base de donn&#233;es . Nous allons commencer par créer une base vide dans laquelle nous allons travailler : . %sql sqlite:///livres_db . La base s&#39;appelle livres_db et est au format sqlite qui est un gestionnaire de base de données relationnelles léger et facile à prendre en main. . Les données seront inscrites dans le fichier livres_db qui vient d&#39;être créé à côté de ce classeur et que vous pourrez télécharger quand vous aurez fini ce TP. . L&#39;objectif est de peupler cette base de données avec la base livres que l&#39;on a étudié lors de la découverte du modèle relationnel. Cette base sera constituée de 3 tables : . AUTEURS | LIVRES | NOTES | . Cr&#233;er une table . Il est temps de commencer à peupler notre base de données. Nous allons commencer par la table AUTEURS. Nous allons donc saisir notre première requête : . %%sql CREATE TABLE &quot;AUTEURS&quot; ( &quot;id&quot; INTEGER PRIMARY KEY, &quot;nom&quot; TEXT, &quot;prenom&quot; TEXT, &quot;langue&quot; TEXT, &quot;annee_nai&quot; INTEGER ); . Quelques explications : . Pour commencer, dans jupyter lorsque nous voudront taper une commande SQL et non du la,gage python, nous inscrirons en première ligne de cellule la commande magique %%sql. N&#39;oubliez jamais de commencer toutes vos cellules ainsi car sinon, la commande sera interprétée par python qui ne connait pas le langage SQL et provoquera une erreur. . La première requête SQL que nous allons apprendre est la requête CREATE TABLE . on insique le nom de la table à créer | entre parenthèse on liste les attributs à mettre ainsi que leur type. | une requête se termine toujours par ; | . Nous avons deux types différents dans notre base de données : . le type TEXT pour tout ce qui est chaîne de caractères | le type INTEGER pour les entiers | . L&#39;attribut id est la clé primaire de la table. C&#39;est un entier qui commence à 1 et qui sera automatiquement incrémenté au fur à mesure que l&#39;on insère des données dans la table. C&#39;est en indiquant PRIMARY KEY après le type dans la déclaration de l&#39;attribut id que sqlite se comporte ainsi. . Ins&#233;rer des enregistrements dans la table . Maintenant que nous avons une table vide, il nous faut la remplir avec les données sur les auteurs. Nous utiliserons pour cela la requête INSERT. Voici son utilisation : . %%sql INSERT INTO AUTEURS (nom, prenom, langue, annee_nai) VALUES (&quot;Orwell&quot;, &quot;George&quot;, &quot;Anglais&quot;, 1903), (&quot;Herbert&quot;, &quot;Frank&quot;, &quot;Anglais&quot;, 1920), (&quot;Asimov&quot;, &quot;Isaac&quot;, &quot;Anglais&quot;, 1920), (&quot;Huxley&quot;, &quot;Aldous&quot;, &quot;Anglais&quot;, 1894), (&quot;Bradbury&quot;, &quot;Ray&quot;, &quot;Anglais&quot;, 1920), (&quot;K. Dick&quot;, &quot;Philip&quot;, &quot;Anglais&quot;, 1928), (&quot;Barjavel&quot;, &quot;René&quot;, &quot;Français&quot;, 1911), (&quot;Boulle&quot;, &quot;Pierre&quot;, &quot;Français&quot;, 1912), (&quot;Van Vogt&quot;, &quot;Alfred Elton&quot;, &quot;Anglais&quot;, 1912), (&quot;Verne&quot;, &quot;Jules&quot;, &quot;Français&quot;, 1828); . Quelques explications : . La requête INSERT s&#39;utilise ainsi : . INSERT INTO ##TABLE## (## attributs dont on donne les valeurs##) VALUES (## enregistrement 1 ##), ... (## enregistrement n ##); . On peut refaire une autre requête INSERT à la suite si on qouhaite ajouter encore des données au bout de la table. . Vous remarquez que l&#39;on ne donne pas de valeur pour l&#39;attribut id. C&#39;est parce qu&#39;on l&#39;a déclaré en PRIMARY KEY. Il est donc automatiquement géré par sqlite. Nous verrons cela en lisant le cpontenu complet de la table. . On est pas obligé de préciser tous les attributs. id est un exemple particulier, mais il est possible d&#39;ommetre d&#39;autres attributs. Ils seront alors affectés d&#39;une valeur nulle. . A l&#39;issue de la requête, sqlite nous informe que 10 lignes ont été créées. . Lire le contenu d&#39;une table . Nous allons à présent utiliser une requête SELECT afin de récupérer le contenu de la table. Ces requêtes peuvent être très sophistiquées comme on va le voir en fin de TP. Pour le moment, nous nous contenterons de la forme la plus simple : . %%sql SELECT * FROM AUTEURS; . Vous voyez donc appraître le contenbu de la table. Vous constatez que la clé primaire id a bien été générée correctement. . Il est possible de stoquer le résultat de cette requête dans une variable pour l&#39;exploiter plus facilement dans jupyter? Voici comment procéder en modifiant légèrement la première ligne : . resultat = %sql SELECT * FROM AUTEURS; . Vous voyez au passage la syntaxe concise permettant de récupérer le résultat d&#39;une requête dans une variable. Cette variable résultat est exploitable dans ce classeur, y compris par python !! . resultat . print(resultat) . resultat[2] . On a donc ici le meilleur des deux mondes : des requêtes SQL et une base de données pour stocker efficacement les données, le langage python pour traiter ces données grâce à des algorithmes faciles à écrire. . A vous de jouer . Notre base n&#39;est pas encore complète : il nous reste à créer les tables LIVRES et NOTES qui doivent refléter le contenu suivant : . titre nom prenom annee_nai langue ann_publi note . 1984 | Orwell | George | 1903 | Anglais | 1949 | 10 | . Dune | Herbert | Frank | 1920 | Anglais | 1965 | 8 | . Fondation | Asimov | Isaac | 1920 | Anglais | 1951 | 9 | . Le meilleur des mondes | Huxley | Aldous | 1894 | Anglais | 1931 | 7 | . Fahrenheit 451 | Bradbury | Ray | 1920 | Anglais | 1953 | 7 | . Ubik | K. Dick | Philip | 1928 | Anglais | 1969 | 9 | . Chroniques martiennes | Bradbury | Ray | 1920 | Anglais | 1950 | 8 | . La nuit des temps | Barjavel | René | 1911 | Français | 1968 | 7 | . Blade Runner | K. Dick | Philip | 1928 | Anglais | 1968 | 8 | . Les Robots | Asimov | Isaac | 1920 | Anglais | 1950 | 9 | . La Planète des singes | Boulle | Pierre | 1912 | Français | 1963 | 8 | . Ravage | Barjavel | René | 1911 | Français | 1943 | 8 | . Le Maître du Haut Château | K. Dick | Philip | 1928 | Anglais | 1962 | 8 | . Le monde des A | Van Vogt | Alfred Elton | 1912 | Anglais | 1945 | 7 | . La Fin de l’éternité | Asimov | Isaac | 1920 | Anglais | 1955 | 8 | . De la Terre à la Lune | Verne | Jules | 1828 | Français | 1865 | 10 | . La table LIVRES . La table LIVRES devra avoir la structure décrite dans l&#39;extrait suivant : . id titre id_auteur ann_publi . ... | ... | ... | ... | . 8 | La nuit des temps | 7 | 1968 | . ... | ... | ... | ... | . l&#39;année de publication est de type INTEGER | id désigne bien sûr la clé primaire | id_auteur est une clé externe faisant référence à l&#39;auteur. | dans l&#39;extrait, la clé id_auteur vaut 7. L&#39;auteur de La nuit des temps est donc Barjavel | on ne renseigne pas la langue ou l&#39;année de naissance de l&#39;auteur car ces informations sont déjà présentes dans la table AUTEURS. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table LIVRES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, &#39;1984&#39;, 1, 1949) in resultat . La table NOTES . Terminons avec la table NOTES. Celle-ci devra avoir la structure décrite dans l&#39;extrait suivant : . id id_livre note . ... | ... | ... | . 7 | 7 | 8 | . ... | ... | ... | . la note est un entier | id désigne bien sûr la clé primaire | id_livre est une clé externe faisant référence au livre évalué. | dans l&#39;extrait, la clé id_livre vaut 7 : il s&#39;agit des Chroniques martiennes qui a eu la note 8. | . %%sql /* # YOUR CODE HERE raise NotImplementedError() */ . Vérifiez votre travail en lisant tous les enregistrements de la table NOTES* dans la variable resultat . # YOUR CODE HERE raise NotImplementedError() resultat . assert (1, 1, 10) in resultat . Notre base de données est à présent complète. Nous allons voir à présent comment faire des requêtes plus élaborées, en particulier en mettant en place des filtres et des tris. . Aller plus loin avec SELECT . Filtre dans une requete SELECT . Supposons que l&#39;on veuille lister seulement les noms et prénoms des auteurs nés avant 1900, voici comment procéder : . %sql SELECT nom, prenom from AUTEURS WHERE annee_nai &lt; 1900; . Compter le nombre de r&#233;ponses d&#39;une requ&#234;te SELECT . Combien y a t-il d&#39;auteurs nés entre 1900 et 1915 ? . nbr = %sql SELECT COUNT(*) from AUTEURS WHERE annee_nai &gt;= 1900 AND annee_nai&lt;=1915; print(nbr) print(&quot;récupérer juste le nombre : &quot;, nbr[0][0]) . S&#233;lectionner des &#233;l&#233;ments distincts . Je m&#39;intéresse au différentes langues des auteurs. Si je fais la requête : . %sql SELECT langue from AUTEURS . cette requête affiche plein de doublons. On peut les enlever grâce à l&#39;utilisation du mot clé DISTINCT. . %sql SELECT DISTINCT langue from AUTEURS . Trier les r&#233;ponses . Nous allons lister tous les auteurs par ordre croissant d&#39;année de naissance . %sql SELECT * from AUTEURS ORDER BY annee_nai; . et par ordre décroissant, on ajoute DESC à la fin de la requête . %sql SELECT * from AUTEURS ORDER BY annee_nai DESC; . A vous de jouer . Donner la liste de tous les titres des livres écrits entre 1920 et 1950. | Combien y en a t-il ? | # Utilisez cette cellule en brouillon pour vos requetes . # Utiliser la syntaxe courte # reponse_i = %sql VOTRE REQUETE pour i=1 ou i=2 # YOUR CODE HERE raise NotImplementedError() . # Vérification des réponses assert reponse_1[3][0] == &#39;Les Robots&#39; assert reponse_2[0][0] == 6 . Il est temps de voir comment réunir les différentes tables afin d&#39;obtenir en un seul tableau les informations souhaitées. . Jointure des tables . Nous voulons récupérer la liste des titres des livres avec le nom de leur auteur. Il faut pour cela piocher les informations dans deux tables différentes en utilisant l&#39;attribut id_auteur comme clé de jointure. . %sql SELECT titre, nom FROM LIVRES JOIN AUTEURS ON LIVRES.id_auteur = AUTEURS.id; . Dans l&#39;exemple ci-dessus, nous avons JOIN LIVRES à AUTEURS en utilisant la clé externe LIVRES.id_auteur comme étant la clé primaire de la table AUTEURS. . A vous de jouer . récupérer dans la variable reponse_1 une liste dont les attributs sont titre, note et ann_publi dans cet ordre. | récupérer dans la variable reponse_2 une liste dont les attributs sont titre, prenom, nom et ann_publi mais triée par ordre de note décroissant. | récupérer dans la variable reponse_3 une liste dont les attributs sont titre, prenom, nom et ann_publi mais dont la note est au moins 9. | # Donner les réponses dans les variables reponse_i en utilisant la syntaxe courte # reponse_i = %sql SELECT blablabla # YOUR CODE HERE raise NotImplementedError() . # Utilisez cette cellule en brouillon pour vos requetes . assert reponse_1[0] == (&#39;1984&#39;,10,1949) assert reponse_2[0] == (&#39;1984&#39;,&quot;George&quot;,&quot;Orwell&quot;,1949) . Mise a jour, effacement : UPDATE et DELETE . Les requêtes UPDATE et DELETE fonctionnent sur le même modèle que les requêtes SELECT. Attention, on a vite fait d&#39;effacer toutes ses données si on ne configure pas bien sa requête. Une bonne habitude à prendre est de tester d&#39;abord ses critères à l&#39;aide d&#39;un SELECT. . Observez les exemples ci-dessous : . %%sql SELECT id FROM AUTEURS WHERE nom=&#39;Verne&#39; . %%sql UPDATE AUTEURS SET nom=&quot;Ze Djoule&quot; WHERE id=10 ; SELECT * FROM AUTEURS ; . %%sql DELETE FROM AUTEURS WHERE id=10; SELECT * FROM AUTEURS; . A vous de jouer . Réinsérez l&#39;auteur Jules Verne ! | Modifiez les notes afin de mettre 10 à chaque note égale ou inférieure à 8 | Supprimez tous les livres écrits au 19e sciecle | # YOUR CODE HERE raise NotImplementedError() . # Vérification de la présence de Jules res = %sql SELECT COUNT(*) FROM AUTEURS WHERE nom=&quot;Verne&quot; assert res[0][0] == 1 # Vérification de l&#39;absence de notes &lt;=8 res = %sql SELECT COUNT(*) FROM NOTES WHERE note &lt;= 8 assert res[0][0] == 0 # Vérification de l&#39;absence de livres du 19e res = %sql SELECT COUNT(*) FROM LIVRES WHERE ann_publi &lt;= 1900 assert res[0][0] == 0 . Attention &#224; la coh&#233;rence des donn&#233;es . Dans une base de données relationnelle il faut être vigilant lors de la suppression d&#39;enregistrements : en effet la suppression d&#39;en enregistement entraîne la suppression de sa clé primaire qui peut être utilisée en tant que clé externe dans une autre table. Cela entraîne la corruption des données. . Il existe en SQL des moyens pour se prémunir de ce type de problèmes mais cela dépasse le cadre de ce cours. .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/21/_04_22_nsi_t_SQL.html",
            "relUrl": "/python/nsi/terminale/bases%20de%20donnees/sql/tp/2020/04/21/_04_22_nsi_t_SQL.html",
            "date": " • Apr 21, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "TP sur les graphes",
            "content": "On représente le réseau autoroutier entre les villes de Rennes (R), Angers (A), Tours (T), Le Mans (M), Paris (P), Lyon (L) et Grenoble (G) à l’aide d’un graphe. Les villes sont les sommets du graphe et les (auto)routes sont représentées par les arêtes du graphe. On a indiqué les distances entre les villes sur les arêtes . Matrice d&#39;adjacence . Ecrire la matrice d&#39;adjacence de ce graphe : . La matrice sera représentée par un tableau à 2 dimensions | la variable s&#39;appellera matrice1 | . # Votre réponse ici matrice1 = [[]] # YOUR CODE HERE raise NotImplementedError() . # Vérification de la réponse assert matrice1[0][6] == 120 . Liste d&#39;adjacence . Ecrire une fonction matrice2liste(matrice, noms) . prenant en paramètres matrice : matrice d&#39;adjacence et noms : noms des sommets dans l&#39;ordre de la matrice | renvoyant un dictionnaire dont les clés sont les sommets et les valeurs sont un tableau de tuples au format (&#39;Nom&#39;, distance). | . Exemple : A est reliée à M, R et T. le dictionnaire commencera par {&#39;A&#39;:[(&#39;M&#39;,100), (&#39;R&#39;, 120), (&#39;T&#39;, 120)] ...} . def matrice2liste(matrice, noms): &quot;&quot;&quot;Renvoie la liste d&#39;adjacence sous format dictionnaire&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . matrice = [[1, 2, 1, 0], [2, 3, 0, 1], [1, 0, 0, 0], [0, 1, 0, 4]] test = matrice2liste(matrice, [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) assert test[&#39;C&#39;] == [(&#39;A&#39;, 1)] assert (&#39;B&#39;, 2) in test[&#39;A&#39;] assert (&#39;D&#39;, 4) in test[&#39;D&#39;] . Liste d&#39;adjacence vers matrice . On considère à présent le graphe représentant les mêmes villes mais les sommets sont pondérés par le temps de parcours en minutes. Voici sa liste d&#39;adjacence au format dictionnaire tel que décrit plus haut: . {&#39;A&#39;: [(&#39;M&#39;, 65), (&#39;R&#39;, 90), (&#39;T&#39;, 80)], &#39;G&#39;: [(&#39;L&#39;, 70)], &#39;L&#39;: [(&#39;G&#39;, 70), (&#39;P&#39;, 230), (&#39;T&#39;, 260)], &#39;M&#39;: [(&#39;A&#39;, 65), (&#39;P&#39;, 95), (&#39;R&#39;, 90), (&#39;T&#39;, 55)], &#39;P&#39;: [(&#39;L&#39;, 230), (&#39;M&#39;, 95), (&#39;T&#39;, 130)], &#39;R&#39;: [(&#39;A&#39;, 90), (&#39;M&#39;, 90)], &#39;T&#39;: [(&#39;A&#39;, 80), (&#39;L&#39;, 260), (&#39;M&#39;, 55), (&#39;P&#39;, 130)]} . Ecrire une fonction liste2matrice(dico) prenant en paramètre un graphe donné par une liste d&#39;adjacence sous format dictionnaire comme ci-dessus et renvoyant la matrice d&#39;adjacence de ce graphe ainsi que un tableau des sommets. . En d&#39;autre termes, la fonction liste2matrice est l&#39;inverse de la fonction matrice2liste précédente. . def liste2matrice(dico): &quot;&quot;&quot;Converti une liste d&#39;adjacence en matrice d&#39;adjacence&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Vérification test = {&#39;A&#39;: [(&#39;A&#39;, 1), (&#39;B&#39;, 2), (&#39;C&#39;, 1)], &#39;B&#39;: [(&#39;A&#39;, 2), (&#39;B&#39;, 3), (&#39;D&#39;, 1)], &#39;C&#39;: [(&#39;A&#39;, 1)], &#39;D&#39;: [(&#39;B&#39;, 1), (&#39;D&#39;, 4)]} l, n = liste2matrice(test) assert n == [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] assert l == [[1, 2, 1, 0], [2, 3, 0, 1], [1, 0, 0, 0], [0, 1, 0, 4]] .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/structure_donnees/graphes/tp/2020/04/20/nsi_t_graphes.html",
            "relUrl": "/python/nsi/terminale/structure_donnees/graphes/tp/2020/04/20/nsi_t_graphes.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Initiation à la Programmation Orientée Objet",
            "content": "Introduction . Objets et POO sont au centre de la manière Python fonctionne. Vous n&#39;êtes pas obligé d&#39;utiliser la POO dans vos programmes - mais comprendre le concept est essentiel pour devenir plus qu&#39;un débutant. Entre autres raisons parce que vous aurez besoin d&#39;utiliser les classes et objets fournis par la librairie standard. . En effet en manipulant les tableaux en python, vous avez certainement remarqué qu&#39;il y a deux syntaxes pour appeler des fonctions : . tableau = [1, 3, 5, 8] taille = len(tableau) tableau.append(11) . le calcul de la longueur du tableau se fait par l&#39;appel à la fonction len() avec une syntaxe identique aux foncitons que vous avez l&#39;habitude d&#39;écrire. | l&#39;ajout d&#39;un élément dans le tableau est un peu différent car la fonction append semble provenir du tableau lui même : dans ce cas, on ne parle pas de fonciton mais de méthode associée à l&#39;objet tableau. | . Un objet est une structure de donnée qui intègre des variables (que l&#39;on nomme propriétés) et des fonctions (que l&#39;on nomme méthodes). Nous allons voir l&#39;intérêt de cette approche, omniprésente dans Python, en particulier lorsqu&#39;on développe des interfaces graphiques, mais avant quelques petits repères historiques et éléments de contexte . Petit historique . La programmation en tant que telle est une matière relativement récente. Etonnament la programmation orientée objet remonte aussi loin que les années 1960. Simula est considéré comme le premier langage de programmation orienté objet. . Les années 1970 voient les principes de la programmation par objet se développent et prennent forme au travers notamment du langage Smalltalk . À partir des années 1980, commence l&#39;effervescence des langages à objets : Objective C (début des années 1980, utilisé sur les plateformes Mac et iOS), C++ (C with classes) en 1983 sont les plus célèbres. . Les années 1990 voient l&#39;âge d&#39;or de l&#39;extension de la programmation par objet dans les différents secteurs du développement logiciel, notemment grâce à l&#39;émergence des systèmes d&#39;exploitation basés sur une interface graphique (MacOS, Linux, Windows) qui font appel abondamment aux principes de la POO. . Programmation proc&#233;durale . La programmation procédurale est celle que vous avez utilisé jusqu&#39;à maintenant : cela consiste à diviser votre programme en blocs réutilisables appelés fonctions. . Vous essayez autant que possible de garder votre code en blocs modulaires, en décidant de manière logique quel bloc est appelé. Cela demande moins d’effort pour visualiser ce que votre programme fait. Cela rend plus facile la maintenance de votre code – vous pouvez voir ce que fait une portion de code. Le fait d’améliorer une fonction (qui est réutilisée) peut améliorer la performance à plusieurs endroits dans votre programme. . Vous avez des variables, qui contiennent vos données, et des fonctions. Vous passez vos variables à vos fonctions – qui agissent sur elles et peut-être les modifient. L&#39;interaction entre les variables et les fonctions n&#39;est pas toujours simple à gérer : les variables locales, globales, les effets de bords que provoquent certaines fonctions qui modifient des variables globales sont souvent source de bugs difficiles à déceler. . On touche ici aux limites de la programmation procédurale, lorsque le nombre de fonctions et de variables devient important. . Cr&#233;ation d&#39;une classe . Nous allons voir un premier exemple simple basé sur la notion de pile vue dans une séquence précédente. . Une pile possède un comportement différent d&#39;un tableau. On a utilisé un tableau pour simuler le comportement d&#39;une pile mais faisant cela, on peut être tenté d&#39;utiliser des fonctionnalités du tableau qui ne sont pas possibles avec une vraie pile comme accéder au dernier élément de la pile en faisant pile[0]. . Pour y remédier nous allons créer un objet Pile qui se comportera exactement comme on le souhaite. Un objet se définit dans une classe qui va nous permettre de définir les propriétés et les méthodes que l&#39;on souhaite intégrer à notre objet Pile. . . Notre classe Pile va nous permettre de définir le modèle de l&#39;objet que l&#39;on souhaite créer. Ce modèle possèdera . 2 propriétés (variables intégrées à l&#39;objet) longueur : la longueur de la pile | sommet : la valeur du sommet de la pile | . | 2 méthodes (fonctions agissant sur cet objet) empile(v) : empile la valeur v sur le sommet de la pile | depile() : sort une valeur de la pile et la renvoie. | . | . Avec ces caractéristiques nous avons donc défini le prototype de notre pile. . Voyons en pratique comment cela se passe. . D&#233;finition de la classe . # Définir une classe - pour le moment vide class Pile(): pass . Pour le moment, on a créé une classe Pile. . On peut voir la classe comme le modèle de fabrication de l&#39;objet. Ce n&#39;est pas un objet réel, juste une manière de décrire comment il est constitué et comment il se comporte. . Une classe seule ne sert à rien. C&#39;est un peu comme voir le nouveau modèle du smartphone de vos rèves sur un site de commerce en ligne : Vous voyez à quoi il ressemble, ses caractéristiques, son prix, ses fonctionnalités... mais vous ne le possédez pas ! . Vous allez donc craquer et passer la commande. Quelques jours plus tard, vous allez posséder l&#39;objet réel, le tenir dans vos mains, le manipuler. Vous avez créé ce qu&#39;on appelle une instance de la classe. . # Créer une instance de l&#39;objet Pile ma_pile = Pile() ma_pile.longueur = 1 ma_pile.sommet = 2 autre_pile = Pile() . Vous avez convaincu quelques uns de vos camarades qui ont aussi commandé le même modèle de smartphone. Ils vont aussi posséder leur propre instance. Ces smartphones fonctionneront de la même manière que le votre car fabriqué à partir des mêmes plans, mais ne possèderont pas les mêmes données : vos photos ou vos apps sont propres à votre instance de votre téléphone et n&#39;apparaîtront pas sur celles de vos amis. . ma_pile.taille . autre_pile.taille . Nous avons créé deux instances de la classe Pile : ma_pile et autre_pile. ma_pile possède à présent deux propriétés : longueur et sommet. Ces propriétés n&#39;existent pas sur aure_pile car l&#39;initialisation de ces propriétés est faite en dehors de la classe, ce qui n&#39;est pas une bonne chose : nous voulons que toutes nos piles soient fabriquées sur le même modèle et donc initialiser les propriétés à l&#39;intérieur de la classe. . Voici comment procéder : . class Pile(): &quot;&quot;&quot;Implémentation basique d&#39;une pile&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;Initialisation de l&#39;instance&quot;&quot;&quot; # Initialisation des propriétés self.longueur = 0 self.sommet = None . Pour initialiser les propriétés, nous avons créé une méthode spéciale à l&#39;intérieur de la classe : la méthode init(). Le nom de cette méthode lancée automatiquement à la création de chaque instance est imposé par Python et ne peut être changé. Attention aux 2 __ à suivre. . Le mot clé self désigne une instance de la classe - imaginez le remplacer par ma_pile ou autre_pile. Puisqu&#39;au moment de concevoir ma classe, ces instances n&#39;existent pas encore, le mot self a été introduit. Il est important de ne pas oublier le self car sinon longueur et sommet seront des variables locales à la fonction init() ce qui n&#39;est pas du tout le but recherché ici ! . Recréons à présent des instances de Pile et commençons à saisir des données : . ma_pile = Pile() autre_pile = Pile() ma_pile.longueur = 1 ma_pile.sommet = 2 . print(ma_pile.longueur) print(autre_pile.longueur) . Tout fonctionne comme prévu : mes deux instances possèdent les mêmes propriétés mais chacune possède ses valeurs qui lui sont propres. . Il est temps de définir nos méthodes. Commençons pas empile. La définition d&#39;une méthode est similaire à la définition d&#39;une fonction à deux détails près . les méthodes sont définies à l&#39;intérieur d&#39;une classe | le premier paramètre d&#39;une méthode est toujours self | . Pour empiler des valeurs dans ma pile je vais avoir besoin d&#39;une structure qui mémorise les données de ma pile. Je vais donc créer une propriété cachée __reste qui contiendra toutes les valeurs de ma pile autre que le sommet. Les 2 __ sont une convention de nommage et signifie que la propriété ou la méthode n&#39;a pas vocation à être appelée à l&#39;extérieur de la définition de la classe, d&#39;où la qualification de cachée. . class Pile(): &quot;&quot;&quot;Implémentation basique d&#39;une pile&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;Initialisation de l&#39;instance&quot;&quot;&quot; # Initialisation des propriétés publiques self.longueur = 0 self.sommet = None # None signifie que la pile est vide # Initialisation du reste de la pile self.__reste = [] def empile(self, valeur): &quot;&quot;&quot;empile la valeur passée en paramètre&quot;&quot;&quot; if self.longueur &gt; 0: # Le sommet de la pile passe dans le reste self.__reste.append(self.sommet) # le nouveau sommet est la valeur qu&#39;on empile self.sommet = valeur # La longueur de la pile augmente de 1 self.longueur += 1 . ma_pile = Pile() ma_pile.empile(3) ma_pile.empile(5) . print(ma_pile.sommet) print(ma_pile.longueur) . En lisant la définition de la méthode empile, vous serez attentif aux points suivants : . le premier paramètre est self, valeur arrive en second | lorsqu&#39;on invoque la méthode empile, on ne passe pas self, on passe juste valeur. | à chaque fois qu&#39;on fait appel à une propriété, on utilise le préfixe self. | . A vous de jouer . L&#39;implémentation de notre pile n&#39;est pas terminée. Vous allez devoir à présent implémenter la méthode depile(). Celle-ci ne prend pas de paramètres (a part bien sûr self que vous n&#39;oublierez pas !) et renvoie la valeur qui a été sorti de la pile. Vous serez attentif . à modifier la propriété longueur | à ne pas provoquer d&#39;erreur si il n&#39;y a rien dans la pile. Dans ce cas, vous renverrez None. | . class Pile(): &quot;&quot;&quot;Implémentation basique d&#39;une pile&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;Initialisation de l&#39;instance&quot;&quot;&quot; # Initialisation des propriétés publiques self.longueur = 0 self.sommet = None # None signifie que la pile est vide # Initialisation du reste de la pile self.__reste = [] def empile(self, valeur): &quot;&quot;&quot;empile la valeur passée en paramètre&quot;&quot;&quot; if self.longueur &gt; 0: # Le sommet de la pile passe dans le reste self.__reste.append(self.sommet) # le nouveau sommet est la valeur qu&#39;on empile self.sommet = valeur # La longueur de la pile augmente de 1 self.longueur += 1 # YOUR CODE HERE raise NotImplementedError() . # Testez votre classe dans cette cellule ma_pile = Pile() ma_pile.empile(3) . # Vérification du fonctionnement de la classe Pile ma_pile = Pile() ma_pile.empile(3) ma_pile.empile(5) assert ma_pile.sommet == 5 assert ma_pile.longueur == 2 assert ma_pile.depile() == 5 assert ma_pile.longueur == 1 assert ma_pile.depile() == 3 assert ma_pile.longueur == 0 . .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/structure_donnees/poo/tp/2020/04/17/nsi_t_Initiation_POO.html",
            "relUrl": "/python/nsi/terminale/structure_donnees/poo/tp/2020/04/17/nsi_t_Initiation_POO.html",
            "date": " • Apr 17, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Implémenter la classe arbre binaire",
            "content": "Dans ce TP nous allons implémenter une classe permettant de représenter un arbre binaire. . Voici le schéma de la structure envisagée pour la classe Arbrebin . . La propriété valeur contiendra la valeur associée au noeud. Les propriétés gauche et droit seront les sous arbres gauche et droit. Ces deux propriétés seront donc des instances de la classe Arbrebin. Si il n&#39;y a pas de sous arbre gauche ou droit, on indiquera la valeur None dans les propriétés correspondantes. . La méthode est_feuille renverra un bouléen selon que l&#39;objet est une feuille ou non. La méthode cree_fils_gauche() prend en paramètre une valeur et crée un fils à gauche dont la valeur est passée en paramètres. . Exemple d&#39;utilisation de la classe Arbrebin . En supposant la classe Arbrebin créée, voici comment on l&#39;utilise pour créer cet arbre : . arbre = Arbrebin(&quot;A&quot;) sous_arbre_gauche = arbre.cree_fils_gauche(&quot;B&quot;) sous_arbre_gauche.cree_fils_gauche(&quot;D&quot;) arbre.cree_fils_droit(&quot;C&quot;) # Quelques vérifications possibles print(arbre.est_feuille()) print(arbre.droit.est_feuille()) print(arbre.gauche.valeur) # Affiche False True B . class Arbrebin(): # la méthode __repr__ définit ce qui sera affiché # lorsqu&#39;on tapera l&#39;objet dans Jupyter ou un terminal # Ici, on affiche juste al valeur du noeud def __repr__(self): return str(self.valeur) # Codez ici les méthodes demandées # YOUR CODE HERE raise NotImplementedError() . # Testez ici les méthodes de votre classe a = Arbrebin(2) a . # Tester l&#39;exemple de départ arbre = Arbrebin(&quot;A&quot;) sous_arbre_gauche = arbre.cree_fils_gauche(&quot;B&quot;) sous_arbre_gauche.cree_fils_gauche(&quot;D&quot;) arbre.cree_fils_droit(&quot;C&quot;) assert not arbre.est_feuille() assert arbre.droit.est_feuille() assert arbre.gauche.valeur == &quot;B&quot; . A présent, vous utiliserez la classe Arbrebin et les méthodes que vous avez développées pour représenter l&#39;arbre suivant dans la variable expr . Les opérations seront représentées par des chaînes de caractères. Les feuilles seront des entiers. . expr = ... # YOUR CODE HERE raise NotImplementedError() . # Validation de la réponse assert expr.valeur == &quot;+&quot; assert expr.droit.valeur == 1 .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/structure_donnees/poo/tp/2020/04/17/nsi_t_I_poo_arbre.html",
            "relUrl": "/python/nsi/terminale/structure_donnees/poo/tp/2020/04/17/nsi_t_I_poo_arbre.html",
            "date": " • Apr 17, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Les dictionnaires",
            "content": "Rappels sur les dictionnaires . Dans cette partie, nous allons fabriquer un carnet d&#39;adresse pour stocker des contacts. . Fabrication d&#39;un contact . Chaque contact sera un dictionnaire dont les clés seront : . nom : Nom et prénom du contact | tel : N° de téléphone | rue : adresse complète | code : code postal | ville : ville | naissance : date de naissance | . Créez un dictionnaire nommé contact correspondant au contact suivant : . Margaret Costa-Royer 08 06 18 37 28 93, avenue Bruneau 13749 Perrot . # YOUR CODE HERE raise NotImplementedError() . # Vérification assert contact[&quot;nom&quot;] == &quot;Margaret Costa-Royer&quot; assert contact[&quot;tel&quot;] == &quot;08 06 18 37 28&quot; assert contact[&quot;ville&quot;] == &quot;Perrot&quot; . Ajouter une nouvelle entrée &quot;passwd&quot; dans le contact ayant pour valeur &#39;s75JWikE&amp;o&#39; . # YOUR CODE HERE raise NotImplementedError() . # Vérification assert contact[&quot;passwd&quot;] == &#39;s75JWikE&amp;o&#39; . G&#233;n&#233;ration automatique d&#39;un contact . Ecrire une fonction genere_contact() . qui ne prend aucun paramètre | qui renvoie un dictionnaire possédant les mêmes clés que le contact ci-dessus, y compris &quot;passwd&quot; | . On pourra utiliser le module faker de python dont un exemple d&#39;utilisation est donné dans la cellile ci-dessous. . from faker import Faker fake = Faker(&quot;fr_FR&quot;) # Générateur de données personnelles pour un français print(fake.name()) print(fake.phone_number()) print(fake.street_address()) print(fake.postcode(), fake.city()) print(fake.password()) . Remarque : Si la cellule ci-dessus provoque une erreur disant que le module faker n&#39;est pas disponible, vous pouvez l&#39;installer dans l&#39;environnement jupyter via la commande . !pip install faker . def genere_contact(): &quot;&quot;&quot;Fabrique un contact factice et renvoie le contact sous forme d&#39;un dictionnaire&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . contact1 = genere_contact() assert type(contact1[&quot;nom&quot;]) == str assert &quot;city&quot; in contact1 . Mise en pratique . Fabrication du carnet d&#39;adresse . Tout est à présent en place pour que nous puissions fabriquer notre carnet d&#39;adresse. . Premi&#232;re impl&#233;mentation . Dans une première approche, nous allons considérer que le carnet d&#39;adresse sera une liste de contacts, chaque contact étant un dictionnaire dont la structure a été définie à la section précédente. . Fabriquez une fonction genere_carnet1 . prenant en paramètre le nombre n de contacts à générer | renvoyant une liste de n contacts générés aléatoirement. | . def genere_carnet1(n): &quot;&quot;&quot;Renvoie une liste de n contacts aléatoires&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # vérification carnet1 = genere_carnet1(10) assert type(carnet1) == list assert &quot;nom&quot; in carnet1[3] . Ecrire à présent une fonction est_present . prenant 2 paramètres : un nom et un carnet d&#39;adresse | renvoyant True si le nom figure dans le carnet d&#39;adresse, False sinon | . def est_present(nom, carnet): &quot;&quot;&quot;Teste si nom est présent dans le carnet d&#39;adresse&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Vérification carnet1 = genere_carnet1(10) nom = carnet1[-1][&quot;nom&quot;] assert est_present(nom, carnet1) assert not est_present(&quot;Lecluse Olivier&quot;, carnet1) . Mesure de performance de la recherche . Nous allons regarder ici comment évolue la vitesse de recherche en fonciton de la taille du carnet d&#39;adresse. On utilisera pour ncela la fonction magique de jupyter : %%timeit. Etudiez la cellule suivante : . # Fabrication d&#39;un carnet de 100 contacts carnet1 = genere_carnet1(100) nom = carnet1[-1][&quot;nom&quot;] # On récupère un nom du carnet nom . %%timeit # On mesure le temps d&#39;une recherche est_present(nom, carnet1) . Vous lisez sous la cellule le temps de recherche. . A présent, on refait l&#39;expérience pour 1000 contacts dans le carnet d&#39;adresse. . carnet1 = genere_carnet1(1000) nom = carnet1[-1][&quot;nom&quot;] # On récupère un nom du carnet nom . %%timeit # On mesure le temps d&#39;une recherche dans ce carnet est_present(nom, carnet1) . Seconde impl&#233;mentation . Vous devez avoir constaté ci-dessus que le temps de recherche est proportionnel à la taille du carnet d&#39;adresse : si celui-ci contient 10 fois plus de contact, la recherche peut être jusqu&#39;à 10 fois plus longue. . Nous allons changer d&#39;approche et fabriquer un carnet d&#39;adresse sous forme d&#39;un dictionnaire dont les clés seront les noms et les valeurs seront les fiches contacts. Ainsi notre carnet d&#39;adresse sera un dictionnaire dont les valeurs seront des dictionnaires ! . Fabriquez une fonction genere_carnet2 . prenant en paramètre le nombre n de contacts à générer | renvoyant un dictionnaire de n contacts générés aléatoirement | . def genere_carnet2(n): &quot;&quot;&quot;Renvoie un dictionnaire de n contacts aléatoires&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Vérification carnet2 = genere_carnet2(10) assert type(carnet2) == dict nom = list(carnet2.keys())[-1] assert type(carnet2[nom]) == dict . Mesure de performance de la recherche . Nous allons regarder pour cette nouvelle implémentation comment évolue la vitesse de recherche en fonction de la taille du carnet d&#39;adresse. Validez les 2 cellules suivantes. . # Fabrication d&#39;un carnet de 100 contacts carnet2 = genere_carnet2(100) nom = list(carnet2.keys())[-1] # On récupère un nom du carnet nom . %%timeit nom in carnet2 # On le recherche . On constate déjà que la recherche est plus rapide que pour la première implémentation du carnet à l&#39;aide d&#39;un tableau. . Refaisons l&#39;expérience avec 100 fois plus de contacts dans le carnet !! . # Fabrication d&#39;un carnet de 10000 contacts carnet2 = genere_carnet2(10000) nom = list(carnet2.keys())[-1] # On récupère un nom du carnet nom . %%timeit nom in carnet2 # On le recherche . Conclusion . Vous le constatez d&#39;après les expériences ci-dessus : le temps de recherche dans le dictionnaire est pratiquement indépendant du nombre d&#39;entrées dans ce dictionnaires, car en multipliant le nombre de contacts par 100, le temps est resté pratiquement identique alors que dans le cas de la recherche dans un tableau, celui-ci est proportionnel à la longueur du tableau. . Le dictionnaire est donc une structure de données optimisée pour la recherche sur les clés. .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/structure_donnees/tp/2020/04/15/nsi_t_dictionnaires.html",
            "relUrl": "/python/nsi/terminale/structure_donnees/tp/2020/04/15/nsi_t_dictionnaires.html",
            "date": " • Apr 15, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Structures de données linéaires",
            "content": "Les piles . On va commencer ce TP par la manipulation des piles, plus faciles à appréhender, et on terminera par la manuipulation des listes chaînées. Rappelons tout d&#39;abord la notion de piles répondant à la règle LIFO : dernier entré, premier sorti. . . Description de la structure . Pour stocker les données dans notre pile, nous utiliserons un tableau python (objet list). Le dernier élément du tableau sera le sommet de la pile. Seul cet élément sera visible. . Exemple : Si la pile est représentée en mémoire par le tableau [2, 3, 5, 8], le sommet de la pile sera 8. Si je dépile le 8, la pile deviendra [2, 3, 5] et le sommet de la pile sera 5. Une fois tous les éléments dépilés, la pile sera vide et représentée par []. . A vous de jouer . Vous allez devoir implémenter les fonctions . p_valeur(p) prend en paramètre une pile p | renvoie le sommet de la pile ou None si la pile est vide | . | p_depile(p) prend en paramètre une pile p | dépile le dernier élément saisi | renvoie la valeur dépilée ou None si la pile est vide | . | p_empile(p, v) prend en paramètre une pile p et une valeur v | empile la valeur v | ne renvoie rien | . | . def p_valeur(p): &quot;&quot;&quot;- prend en paramètre une pile p - renvoie le sommet de la pile Exemple : &gt;&gt;&gt; p_valeur([2, 3, 5]) &gt;&gt;&gt; 5 &gt;&gt;&gt; p_valeur([]) &gt;&gt;&gt; None &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . assert p_valeur([]) is None assert p_valeur([2, 3, 5]) == 5 . def p_depile(p): &quot;&quot;&quot;- prend en paramètre une pile p - dépile le dernier élément saisi - renvoie le sommet de la pile Exemple : &gt;&gt;&gt; p_valeur([2, 3, 5]) &gt;&gt;&gt; 5 &gt;&gt;&gt; p_valeur([]) &gt;&gt;&gt; None &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . p=[2, 3, 5] assert p_depile(p) == 5 assert p == [2, 3] assert p_depile([]) is None . def p_empile(p, v): &quot;&quot;&quot;- prend en paramètre une pile p et une valeur v - empile la valeur v Exemple : &gt;&gt;&gt; p = [2, 3] &gt;&gt;&gt; p_empile(p, 5) &gt;&gt;&gt; p &gt;&gt;&gt; [2, 3, 5] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . p = [2, 3] p_empile(p, 5) assert p == [2, 3, 5] . Les files . Rappelons la notion de files répondant à la règle FIFO : premier entré, premier sorti. . . Description de la structure . Pour stocker les données dans notre file, nous utiliserons un tableau python (objet list). . le dernier élément du tableau sera l&#39;avant de la file. Seul cet élément sera visible | le premier élément du tableau sera l&#39;arrière de la file | . Exemple : Si la sile est représentée en mémoire par le tableau [2, 3, 5, 8], l&#39;avant de la file sera 8 et l&#39;arrière de la file sera 2. Si on ajoute 1 à l&#39;arrière de la file, celle-ci contiendra [1, 2, 3, 5, 8]. Une fois tous les éléments dépilés, la file sera vide et représentée par []. . A vous de jouer . Vous allez devoir implémenter les fonctions . f_valeur(f) prend en paramètre une file f | renvoie la valeur à l&#39;avant de la file ou None si la file est vide | . | f_defile(f) prend en paramètre une file f | défile l&#39;élément situé à l&#39;avant de la file | renvoie la valeur défilée ou None si la file est vide | . | f_emfile(f, v) prend en paramètre une file f et une valeur v | emfile la valeur v à l&#39;arrière de la file | ne renvoie rien | . | . def f_valeur(f): &quot;&quot;&quot;- prend en paramètre une file f - renvoie la valeur à l&#39;avant de la file ou None si la file est vide Exemple : &gt;&gt;&gt; f_valeur([2, 3, 5]) &gt;&gt;&gt; 5 &gt;&gt;&gt; f_valeur([]) &gt;&gt;&gt; None &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . assert f_valeur([]) is None assert f_valeur([2, 3, 5]) == 5 . def f_defile(f): &quot;&quot;&quot;- prend en paramètre une file f - défile l&#39;élément situé à l&#39;avant de la file - renvoie la valeur défilée ou None si la file est vide Exemple : &gt;&gt;&gt; f = [2, 3, 5, 8] &gt;&gt;&gt; f_defile(f) &gt;&gt;&gt; 8 &gt;&gt;&gt; f &gt;&gt;&gt; [2, 3, 5] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . f = [2, 3, 5, 8] assert f_defile(f) == 8 assert f == [2, 3, 5] . def f_enfile(f, v): &quot;&quot;&quot;- prend en paramètre une file f et une valeur v - enfile la valeur v à l&#39;arrière de la file Exemple : &gt;&gt;&gt; f = [2, 3, 5, 8] &gt;&gt;&gt; f_enfile(f, 1) &gt;&gt;&gt; f &gt;&gt;&gt; [1, 2, 3, 5, 8] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . f = [2, 3, 5, 8] f_enfile(f, 1) assert f == [1, 2, 3, 5, 8] . Les listes cha&#238;n&#233;es . Description de la structure . On rappelle que la structure d&#39;une liste chaînée ressemble à ceci : . L&#39;illustration montre une liste chaînée composée de 4 maillons. Chaque maillon est composé de 2 champs : une valeur et un pointeur vers le maillon suivant. . Pour implémenter une liste chaînée en python nous utiliserons . un tableau à 2 éléments décrivant un maillon le premier élément du tableau est la valeur du maillon | le second élément est l&#39;indice du maillon suivant (ou None pour le dernier élément) | . | un tableau constitué de la liste de tous les maillons | . La liste chaînée donnée en illustration pourra donc être représentée ainsi : . maillons = [[3, 2], [8,None], [5, 1], [2,0]] premier = 3 . Vous constaterez que j&#39;ai volontairement inscrit dans le tableau maillons les éléments de la liste dans le désordre car il n&#39;y a aucune raison que l&#39;ordre des éléments corresponde à l&#39;ordre dans le tableau maillons si par exemple on insère en cours de route des éléments au milieu de la liste. . la variable premier contient l&#39;indice du premier élément de la liste, c&#39;est donc le maillon [2,0] correspondant à la valeur 2. L&#39;élément suivant sera le maillon à l&#39;indice 0 dans le tableau donc [3,2] dont la valeur est 3. Ensuite on accède au maillon d&#39;indice 2 donc [5,1] de valeur 5 pour terminer par le maillon [8,None] de valeur 8 marquant la fin de la liste. Au final la liste est donc bien $$2 - 3 - 5 - 8$$ On va supposer dans la suite que la variable maillons est globale et contiendra tous les maillons de toutes les listes avec lesquelles nous travaillerons. Une liste sera donc définie uniquement par l&#39;indice de son premier élément dans le tableau maillons. . A vous de jouer . Vous allez devoir implémenter les fonctions . l_premier(p) prend en paramètre l&#39;indice du premier élément d&#39;une liste p | renvoye la valeur du premier élément de la liste | . | l_valeurs(p) prend en paramètre l&#39;indice du premier élément d&#39;une liste p | renvoye un tableau avec toutes les valeurs de la liste | . | l_insere_debut(p, v) prend en paramètre l&#39;indice du premier élément d&#39;une liste p et la valeur à insérer v | renvoye l&#39;indice du premier élément de la nouvelle liste où la valeur v a été insérée au début | . | l_insere_fin(p, v) prend en paramètre l&#39;indice du premier élément d&#39;une liste p et la valeur à insérer v | insère à la fin de la liste la valeur v | renvoye p car la liste commence par le même élément | . | l_nouveau(v) prend en paramètre une valeur v | renvoie l&#39;indice du premier élément de cette liste constituée du seul élément v | . | l_scinde(p, i) prend en paramètre une liste p et in indice i | scinde la liste p en deux listes dont la première possède i éléments | renvoie l&#39;indice du premier élément de la seconde sous liste (la première commence toujours à p) | . | l_concat(p1, p2) prend en paramètre deux listes p1 et p2 | concatène (met bout à bout) les deux listes | renvoie p1 : début de la liste concaténée. | . | . def l_premier(p): &quot;&quot;&quot;- prend en paramètre l&#39;indice du premier élément d&#39;une liste p - renvoye la valeur du premier élément de la liste Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; l_premier(3) &gt;&gt;&gt; 2 &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Testez votre fonction maillons = [[3, 2], [8,None], [5, 1], [2,0]] assert l_premier(3) == 2 . def l_valeurs(p): &quot;&quot;&quot; - prend en paramètre l&#39;indice du premier élément d&#39;une liste p - renvoye un tableau avec toutes les valeurs de la liste Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; l_valeurs(3) &gt;&gt;&gt; [2, 3, 5, 8] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Testez votre fonction maillons = [[3, 2], [8,None], [5, 1], [2,0]] assert l_valeurs(3) == [2, 3, 5, 8] . def l_insere_debut(p, v): &quot;&quot;&quot;-prend en paramètre l&#39;indice du premier élément d&#39;une liste p et la valeur à insérer v -renvoye l&#39;indice du premier élément de la nouvelle liste où la valeur v a été insérée au début Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; p = l_insere_debut(-5) &gt;&gt;&gt; l_valeurs(p) &gt;&gt;&gt; [-5, 2, 3, 5, 8] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Testez votre fonction maillons = [[3, 2], [8,None], [5, 1], [2,0]] p = l_insere_debut(3,-5) assert l_valeurs(p) == [-5, 2, 3, 5, 8] . def l_insere_fin(p, v): &quot;&quot;&quot;-prend en paramètre l&#39;indice du premier élément d&#39;une liste p et la valeur à insérer v - insère à la fin de la liste la valeur v - renvoye p car la liste commence par le même élément Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; p = l_insere_fin(3, 11) &gt;&gt;&gt; l_valeurs(p) &gt;&gt;&gt; [2, 3, 5, 8, 11] &quot;&quot;&quot; i = p # YOUR CODE HERE raise NotImplementedError() . # Testez votre fonction maillons = [[3, 2], [8,None], [5, 1], [2,0]] p = l_insere_fin(3, 11) assert l_valeurs(p) == [2, 3, 5, 8, 11] . def l_nouveau(v): &quot;&quot;&quot;- prend en paramètre une valeur v - renvoie l&#39;indice du premier élément de cette liste constituée du seul élément v Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; p = l_nouveau(15) &gt;&gt;&gt; l_valeurs(p) &gt;&gt;&gt; [ 15 ] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . # Testez votre fonction maillons = [[3, 2], [8,None], [5, 1], [2,0]] p = l_nouveau(15) assert l_valeurs(p) == [ 15 ] . def l_scinde(p, i): &quot;&quot;&quot;- prend en paramètre une liste p et in indice i - scinde la liste p en deux listes dont la première possède i éléments - renvoie l&#39;indice du premier élément de la seconde sous liste (la première commence toujours à p) Exemple : maillons = [[3, 2], [8,None], [5, 1], [2,0]] &gt;&gt;&gt; p1 = 3 &gt;&gt;&gt; p2 = l_scinde(p1, 2) &gt;&gt;&gt; l_valeurs(p1) &gt;&gt;&gt; [ 2, 3 ] &gt;&gt;&gt; l_valeurs(p2) &gt;&gt;&gt; [ 5, 8 ] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . maillons = [[3, 2], [8,None], [5, 1], [2,0]] p1 = 3 p2 = l_scinde(p1, 2) assert l_valeurs(p1) == [2, 3] assert l_valeurs(p2) == [5, 8] p2 . def l_concat(p1, p2) : &quot;&quot;&quot;- prend en paramètre deux listes p1 et p2 - concatène (met bout à bout) les deux listes - renvoie p1 : début de la liste concaténée. Exemple : [[3, None], [8, None], [5, 1], [2, 0]] &gt;&gt;&gt; l_concat(3, 2) &gt;&gt;&gt; l_valeurs(3) &gt;&gt;&gt; [ 2, 3, 5, 8] &quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . maillons = [[3, None], [8, None], [5, 1], [2, 0]] assert l_concat(3, 2) == 3 assert l_valeurs(3) == [2, 3, 5, 8] .",
            "url": "https://fastpages.fast.ai/python/nsi/terminale/structure_donnees/tp/2020/04/14/nsi_t_listes_piles_files.html",
            "relUrl": "/python/nsi/terminale/structure_donnees/tp/2020/04/14/nsi_t_listes_piles_files.html",
            "date": " • Apr 14, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Le pendu",
            "content": "Pr&#233;paration du jeu . Pour commencer, nous allons créer un dictionnaire en chargeant une liste de mots figurant dans un fichier texte. . L&#39;import d&#39;un fichier texte dans une liste se fait facilement en Python : . liste_mots = [] with open(&quot;liste_mots.txt&quot;,&quot;r&quot;) as fichier: liste_mots = fichier.readlines() len(liste_mots) . 336529 . Pour choisir un mot aléatoire dans cette liste, nous utiliserons la fonction choice du module random. . Le mot choisi contient un caractère de fin de ligne parasite ( n) que nous éliminerons grâce au slicing : on garde tous les caractères depuis le début jusqu&#39;au dernier, exclu. . Exécutez plusieurs fois la cellule ci-dessous pour voir les différents choix de mots aléatoires. . from random import choice mot_inconnu = choice(liste_mots)[:-1] mot_inconnu . D&#233;veloppement des diff&#233;rentes fonctions utiles au jeu . Créez une fonction masque prenant en paramètre un mot et renvoyant une chaîne masquée contenant autant de &#39;-&#39; qu&#39;il y a de lettres dans le mot. . Par exemple : masque(&#39;python&#39;) renvoie &#39;&#39; . def masque(mot): # YOUR CODE HERE raise NotImplementedError() . assert masque(&#39;python&#39;) == &#39;&#39; . Créez une fonction devine prenant en paramètres . le mot inconnu | le mot masqué | une lettre et renvoyant le masque dans lequel la lettre proposée apparaît à toutes les places où celle-ci est présente dans le mot. | . Exemple : devine(&#39;python&#39;,&#39;p-n&#39;,&#39;t&#39;) renvoie &#39;p-t--n&#39; . def devine(mot, mot_masque, lettre): # YOUR CODE HERE raise NotImplementedError() . assert devine(&#39;python&#39;,&#39;p-n&#39;,&#39;t&#39;) == &#39;p-t--n&#39; . Jouer une partie . Nous disposons à présent des fonctions nécessaires pour jouer une partie. Il ne nous reste donc plus qu&#39;à réaliser la fonction jouer qui . prend en paramètre une lettre ainsi qu&#39;une liste contenant le mot à deviner | le mot masqué (ou partiellement découvert) | le nb d&#39;erreurs réalisées | . | renvoie la liste actualisée (avec le mot masqué ou le nombre d&#39;erreurs) | . Exemples : . jouer(&#39;a&#39;, [&quot;python&quot;, &quot;&quot;,0]) renvoie [&quot;python&quot;, &quot;&quot;,1] car on a une erreur | jouer(&#39;p&#39;, [&quot;python&quot;, &quot;&quot;,0]) renvoie [&quot;python&quot;, &quot;p--&quot;,1] | . def jouer(lettre, etat): # YOUR CODE HERE raise NotImplementedError() . mot = &quot;python&quot; mask = masque(mot) nb_err = 0 assert jouer(&quot;a&quot;, [mot, mask, nb_err]) == [&#39;python&#39;, &#39;&#39;, 1] assert jouer(&quot;p&quot;, [mot, mask, nb_err]) == [&#39;python&#39;, &#39;p--&#39;, 0] . mot = &quot;python&quot; etat = [mot, masque(mot),0] etat = jouer(&quot;a&quot;, [mot, mask, nb_err]) etat . etat = jouer(&quot;p&quot;, etat) etat . etat = jouer(&quot;u&quot;, etat) etat . etat = jouer(&quot;n&quot;, etat) etat . etat = jouer(&quot;y&quot;, etat) etat . etat = jouer(&quot;t&quot;, etat) etat . etat = jouer(&quot;o&quot;, etat) etat . etat = jouer(&quot;h&quot;, etat) etat .",
            "url": "https://fastpages.fast.ai/miniprojet/isn/2020/03/07/pendu.html",
            "relUrl": "/miniprojet/isn/2020/03/07/pendu.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Intégration - Méthode des rectangles",
            "content": "Probl&#233;matique . On considère dans cette activité la fonction $f$ définie sur $[0 ;2]$ par $f (x) = 4 − x^2$ et $ mathcal C$ sa courbe représentative dans un repère orthonormé. . L&#39;objectif de cette activité est de calculer l&#39;aire du domaine délimité . d&#39;une part par les droites d&#39;équation $x=0$ et $x=2$ | d&#39;autre part par l&#39;axe des asbcisses et la courbe $ mathcal C$ | . . En d&#39;autre termes, nous cherchons à déterminer l&#39;aire hachurée en rouge sous la courbe $ mathcal C$ pour $x$ compris entre 0 et 2. . La m&#233;thode des rectangles . L’idée va être d’encadrer l’aire recherchée par deux aires que l’on peut calculer aisément. On utilise pour cela des figures très élémentaires : des rectangles. . Nous allons calculer un minorant de l&#39;aire en inscrivant des rectangles sous la courbe (voir rectangles rouges) et un majorant de l&#39;aire en construisant des rectangles au dessus de la courbe (voir rectangles bleus). . . En effet, l&#39;aire d&#39;un rectangle est facile à calculer. Il suffit donc de faire la somme des aires de chacun des rectangles pour obtenir un encadrement de l&#39;aire recherchée. . Rectangles inf&#233;rieurs (rouges) . On cherche à déterminer l&#39;aire du rectangle dont la base est située entre les abscisses $x$ et $x+dx$ (dx désignant la largeur de chaque rectangle) et dont la hauteur est telle que le rectangle soit situé juste sous la courbe $ mathcal C$. . Exprimer cette aire en fonction de $x$, $dx$ et la fonction $f$ . # collapse # aireInf = dx * f(x+dx) . . Rectangles sup&#233;rieurs (bleus) . On cherche à déterminer l&#39;aire du rectangle dont la base est située entre les abscisses $x$ et $x+dx$ (dx désignant la largeur de chaque rectangle) et dont la hauteur est telle que le rectangle soit situé juste au dessus de la courbe $ mathcal C$. . Exprimer cette aire en fonction de $x$, $dx$ et la fonction $f$ . # collapse # aireSup = dx * f(x) . . Le programme . # On définit notre fonction f def f(x): return 4-x*x . Compléter le programme ci-dessous dont le but est de calculer la somme des aires des rectangles sous la courbe (rouges) et la somme des aires des rectangles au dessus de la courbe (bleus). . # Complétez l&#39;algorithme def rectangles(xmin, xmax, n): dx=... # ... Largeur d&#39;un rectangle sommeInf = ... # Aire des rectangles inférieurs sommeSup = ... # Aire des rectangles supérieurs # Traitement x=... # Bord gauche du rectangle considéré for i in range(...): # répéter ... fois sommeInf = ... sommeSup = ... x = ... return (sommeInf, sommeSup) . # collapse def rectangles(xmin, xmax, n): dx=(xmax - xmin) / n # ... Largeur d&#39;un rectangle sommeInf = 0 # Aire des rectangles inférieurs sommeSup = 0 # Aire des rectangles supérieurs # Traitement x=xmin # Bord gauche du rectangle considéré for i in range(n): # Répéter n fois sommeInf = sommeInf + dx*f(x+dx) sommeSup = sommeSup + dx*f(x) x = x + dx return (sommeInf, sommeSup) . . # Votre calcul ici r = rectangles(0, 2, 5) r . (4.4799999999999995, 6.08) . Quelle est l&#39;incertitude commise par cet encadrement ? . r[1]-r[0] . 1.6000000000000005 . Comment augmenter la précision de ce calcul et diminuer cette incertitude ? Modifier votre programme pour donner une valeur de l&#39;aire sous la courbe d&#39;une précision d&#39;au moins 0,1 . # collapse # On augmente le nb de rectangles # jusqu&#39;à obtenir la précision souhaitée r = rectangles(0, 2, 100) print(&quot;Précision : &quot;, r[1]-r[0]) r . . Précision : 0.08000000000000007 . (5.293199999999998, 5.373199999999998) . Modification de l&#39;algorithme . On souhaite à présent modifier le programme afin d&#39;obtenir un encadrement avec une précision fixée au départ. Par exemple : obtenir un encadrement de l&#39;aire sous la courbe avec une précision d&#39;au moins 0,0001. Que faut-il modifier dans notre algorithme pour arriver à ce résultat ? . Ecrire un programme donnant un encadrement de l&#39;aire avec une précision d&#39;au moins 0,0001. . Combien avez-vous utilisé de rectangles pour arriver à cette précision ? . # collapse # On introduit une boucle tant que # pour obtenir la rpécision souhaitée : # on appelle la fonction rectangles en multipliant par 10 # le nombre de rectangles à chaque nouvel appel def aire(xmin, xmax, prec): p = 1 n=1 while p &gt; prec: n = 10*n r = rectangles(xmin, xmax, n) p = r[1] - r[0] return (r, n) . . aire(0, 2, 0.0001) . ((5.33329333320509, 5.333373333205089), 100000) . Notation . On note l&#39;aire sous la courbe que nous venons de calculer : $ displaystyle int_0^2 4-x^2~ dx approx 5,3333$ .",
            "url": "https://fastpages.fast.ai/maths/ts/algorithmique/2020/03/07/TS-Activite-methode-rectangles.html",
            "relUrl": "/maths/ts/algorithmique/2020/03/07/TS-Activite-methode-rectangles.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Découvrir le binaire",
            "content": "bin(2) . int(&#39;0b10&#39;,2) . En utilisant ces commandes, . donner la valeur binaire du nombre décimal 123 | donner la valeur décimale du nombre binaire 1001110 | . Mais comment fait-il ? Nous allons réécrire nos propres fonctions. Commençons par remarquer que l&#39;écriture binaire d&#39;un nombre est donné par Python sous forme d&#39;une chaîne de caractères, c&#39;est à dire un texte délimité par des guillemets. Nous allons commencer par voir quelques règles basiques de manipulation des chaînes. . Manipulations de cha&#238;nes de caract&#232;re . maChaine=&quot;Ceci est une chaine&quot; autreChaine=&quot; de caractère&quot; . Concat&#233;nation . On utilise l&#39;opération &#39;+&#39; pour mettre deux chaînes de caractères bout à bout. . maChaine + autreChaine . Attention : Une chaîne de caractère n&#39;est pas un nombre. Observez attentivement cet exemple : . a=&#39;2&#39; b=&#39;5&#39; a+b . a=&#39;2&#39; b=5 a+b . a=2 b=5 a+b . Conversion Cha&#238;nes - Nombres . Il est possible de convertir un nombre en chaîne de caractère et réciproquement. On utilise pour cela les fonctions str et int de python : . a=12 type(a) . b=str(a) type(b) . Remarquez la fonction type permettant de connaître le type d&#39;une variable. $a$ est de type entier alors que $b$ est de type chaîne. . b . a+a . b+b . int(b+b) . le slicing o&#249; comment d&#233;couper des parties d&#39;une cha&#238;ne de caract&#232;re . On peut extraire une sous chaîne de caractère à partir d&#39;une chaîne en faisant suivre la chaîne de crochets contenant les indices de début et de fin de la chaîne que l&#39;on souhaite extraire. Il faut savoir qu&#39;en python, les indices commencent à 0. Observez les exemples suivants : . maChaine=&quot;Ceci est un texte&quot; . maChaine[0] . maChaine[6] . len(maChaine) . maChaine[16] . maChaine[17] . maChaine[0:3] . maChaine[5:10] . Il est possible de ne pas préciser le second indice après :. Dans ce cas, on obtient la fin de la chaîne à partir de l&#39;indice de début précisé. . maChaine[3:] . Renverser une cha&#238;ne . Il y a beaucoup à voir sur le slicing, en particulier l&#39;utilisation des indices et des pas négatifs, mais nous en avons déjà assez vu. Juste un dernier exemple pratique permettant de renverser une chaîne de caractère . maChaine[::-1] . Parcourir une cha&#238;ne de caract&#232;re par une boucle pour . Il est possible de parcourir un à un chacun des caractères d&#39;une chaîne très facilement en python. Observez cet exemple et admirez à quel point la syntaxe Python est proche du langage naturel ! . nb=0 for c in maChaine: print(&quot;Je lis le caractère : &quot;,c) nb +=1 print(f&quot;Il y a {nb} caractères dans cette chaîne&quot;) . A vous de jouer . Vous allez créer une fonction somme . prenant en paramètre un nombre entier $n$ | renvoyant la somme des chiffres composant $n$ | . Exemple : somme(1234) devra renvoyer 10 . Indication : Vous pourrez . convertir $n$ en chaîne de caractère | parcourir chaque caractère | ajouter le chiffre correspondant à une variable total | retourner la valeur de total | . Remarque : Rappelez vous que 1+2 vaut 3 mais &#39;1&#39;+&#39;2&#39; vaut &#39;12&#39; !! je dis ça, je dis rien :) . # A vous de compléter ... def . Convertir un binaire en d&#233;cimal . Vous êtes maintenant armés pour convertir un binaire en décimal. Avant toute chose, avant d&#39;écrire une fonction, on doit se faire une idée très précise de son fonctionnement avec un papier et un crayon. . Prenons l&#39;exemple du nombre $b=&#39;0b1101&#39;$. Pour le convertir en décimal, nous allons le parcourir de la gauche vers la droite et totaliser au fur à mesure le nombre obtenu avec des puissances de 2. Observez la démarche : . On se débarasse de l&#39;entête b=&#39;1101&#39; | On initialise une variable $n leftarrow$ 0 | On parcourt b de gauche à droite, caractère par caractère à l&#39;aide d&#39;une boucle | On lit &#39;1&#39;. On l&#39;ajoute donc à $n$ qui vaut 1 | On lit &#39;1&#39; à nouveau. Avant de l&#39;ajouter à $n$, il faut multiplier $n$ par 2 (10 en binaire) du fait du décalage des bit d&#39;un rang vers la gauche. $n$ vaut donc à présent $2 times 1 + 1$ soit 3 -c&#39;est l&#39;écriture décimale de 11 en binaire, tout va bien ! | On lit &#39;0&#39;. Comme précédemment, on va multiplier $n$ par 2 afin de tenir compte du décalage des bits vers la gauche. $n$ vaut alors 6 et comme on a lu 0, on ajoute rien. | Pour finir, on lit &#39;1&#39;. On va donc multiplier $n$ par 2 et ajouter 1, ce qui nous donne $2 times 6+1$ soit 13 | . On renvoie le résultat final n=13 | int(&#39;0b1101&#39;,2) . Pour bien vous imprégner de l&#39;algorithme, appliquez cette même méthode pour convertir &#39;0b101110&#39; en décimal sur votre feuille. Ne validez la cellule suivante qu&#39;une fois le calcul fait à la main !! . int(&#39;0b101110&#39;,2) . Si on résume l&#39;algorithme, il ressemble à ceci : . tronquer la chaîne b pour enlever &#39;0b&#39; Initialiser $n à 0 parcourir la chaîne b multiplier n par deux et ajouter le chiffre binaire lu renvoyer le résultat n . Il ne vous reste plus qu&#39;à créer la fonction bin2dec . qui prend en entrée une chaîne au format binaire (comme&#39;0b1101&#39;) | qui renvoie l&#39;écriture décimale du nombre | . Ainsi bin2dec(&#39;0b1101&#39;) devra renvoyer 13 . A vous de jouer . # A vous de compléter ... def . Convertir un d&#233;cimal en binaire . Nous allons faire maintenant l&#39;opération inverse, c&#39;est à dire passer d&#39;une écriture décimale à binaire : Exemple : dec2bin(13) devra renvoyer &#39;0b1101&#39; . Pour cette seconde fonction, vous commencerez par vous familiariser avec l&#39;algorithme en le faisant fonctionner à la main sur des exemples. Ce n&#39;est qu&#39;une fois à l&#39;aise avec le calcul à la main que vous pourrez apprendre à pyhton comment faire. . L&#39;algorithme consiste à faire des divisions successives par 2 et à regarder le reste. Le reste d&#39;une division par 2 est 0 si le nombre est pair, ou 1 si le nombre est impair. Cela donne justement les chiffres de notre nombre binaire !! Observez l&#39;exemple . n Quotient par 2 reste . 13 | 6 | 1 | . 6 | 3 | 0 | . 3 | 1 | 1 | . 1 | 0 | 1 | . On s&#39;arrète lorsque le quotient par 2 est nul. Les restes successifs sont 1, 0 1 et 1 ce qui est justement l&#39;écritune binaire de 13 écrit de la droite vers la gauche, mais vous savez renverser une chaîne de caractère n&#39;est-ce pas :) . Division et reste en Python . Avant de vous laisser créer la fonction, voici les opérateurs qui vous seront utiles : . Division entière : // | reste : % | . Regardez sur cet exemple : . 13//2 . 13%2 . Le quotient de 13 par 2 est bien 6 et il reste 1. . A vous de jouer. . Après vous être exercés sur papier à la conversions de nombres de decimal en binaire, il ne vous reste plus qu&#39;à créer la fonction dec2bin . qui prend en entrée un entier décimal | qui renvoie l&#39;écriture binaire du nombre sous forme d&#39;une chaîne &#39;0b....&#39; | . # A vous de compléter ... def .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/TP_binaire.html",
            "relUrl": "/python/isn/2020/03/07/TP_binaire.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Utilisation de threads avec le réseau",
            "content": "import socket # en plus de socket, on utilise les threads from threading import Thread # fonction qui va gérer un client (boucle avec sortie si &#39;exit&#39; reçu) # cette fonction sera appelée dans un nouveau thread à chaque connexion def gereClient(sockclient,addr): sock=sockclient while True: data = sock.recv(BUFSIZ).decode(&quot;Utf8&quot;) if data == &#39;exit&#39;: break else: msg = &#39;echo : &#39; + data # notre serveur est tjs le même sock.send(msg.encode(&quot;Utf8&quot;)) sock.send(&quot;FIN&quot;.encode(&quot;Utf8&quot;)) sock.close() BUFSIZ = 1024 #HOST = socket.gethostname() HOST=&#39;0.0.0.0&#39; # Toutes les addresses de la machine à l&#39;écoute PORT = 4567 ADDR = (HOST, PORT) sockserveur = socket.socket() sockserveur.bind(ADDR) # on peut éventuellement mettre un paramètre plus grand à listen # si on veut que le serveur ne refuse pas une connexion # alors qu&#39;il est en train d&#39;en traiter une autre # (temps de passage de la connexion à un nouveau thread) sockserveur.listen(1) # boucle pour les connexions des clients, sans fin while True: print (&quot;Serveur à l&#39;écoute…&quot;) sockclient, addr = sockserveur.accept() print (&#39;...connexion de : &#39;, addr) # quand un client se connecte, on crée un thread &quot;pour lui&quot; # contenant la fonction de gestion de client th=Thread(target=gereClient,args=(sockclient,addr)) th.start() . Explications . La commande de reception de donnée depuis le réseau est . sock.recv(BUFSIZ).decode(&quot;Utf8&quot;) . Cette commande est bloquante, ce qui signifie que lorsque le serveur est en attente d&#39;un message en provenance d&#39;un client, il ne peut rien faire d&#39;autre, en particulier, il ne peut pas traiter les demandes d&#39;autres clients éventuels. . Cette situation est bien sûr intenable dans le cadre d&#39;un usage classique. Pour contourner cette difficulté, nous intégrons cette commande bloquante dans une fonction qui sera exécutée en parallèle du programme principal qui restera disponible pour traiter les autres connexions clients. . Pour exécuter une fonction en parallèle, on fait appel à la librairie Threading de Python : Un thread étant un morceau de programme s&#39;éxécutant en parallèle du programme qui l&#39;appelle. Nous créons donc grâce à la commande . Thread(target=gereClient,args=(sockclient,addr)) . un appel non bloquant à la fonction gereClient, et ce pour chaque client qui se connecte. . Nous pouvons donc traiter simultanément la connexion de plusieurs clients au même serveur. . Le client . from tkinter import * from socket import * from threading import Thread liaison = socket(AF_INET, SOCK_STREAM) # socket client def gestionClient(): # Communication client exécuté en parallèle dans un thread message=&quot;&quot; while message.upper() != &quot;FIN&quot; : message = liaison.recv(1024).decode(&quot;utf8&quot;) # Commande bloquante listeMsg.insert(END, message) # On affiche le message reçu etatStr.set(&quot;Connexion terminée.&quot; ) liaison.close() def connect(): SERVEUR=ipAddr.get() PORT=eval(ipPort.get()) try: liaison.connect((SERVEUR, PORT)) etatStr.set(&quot;Connexion établie&quot;) th=Thread(target=gestionClient) th.start() except error: etatStr.set(&quot;La connexion a échoué.&quot;) liaison.close() def envoi(): liaison.send(msgStr.get().encode(&quot;utf8&quot;)) msgStr.set(&quot;&quot;) fenetre=Tk() fenetre.title=&quot;Client réseau&quot; ## textes variables ipAddr=StringVar() ipAddr.set(&#39;127.0.0.1&#39;) ipPort=StringVar() ipPort.set(&quot;4567&quot;) etatStr=StringVar() etatStr.set(&quot;Etat de la connection...&quot;) msgStr=StringVar() ## Interface graphique connFrame=Frame(fenetre,bd=1, relief=SUNKEN) # Cadre de connection msgFrame=Frame(fenetre,bd=1, relief=SUNKEN) # Cadre d&#39;envoi ipEntry=Entry(connFrame,textvariable=ipAddr) portEntry=Entry(connFrame,textvariable=ipPort) btnConnect=Button(connFrame,text=&quot;Connexion&quot;,command=connect) etatLbl=Label(fenetre,textvariable=etatStr) listeMsg = Listbox(fenetre) msgLbl=Label(msgFrame,text=&quot;Message&quot;) msgEntry=Entry(msgFrame,textvariable=msgStr) msgSend=Button(msgFrame,text=&quot;Envoyer&quot;,command=envoi) ## positionnement des widgets connFrame.pack(padx=5,pady=5) ipEntry.pack(side=LEFT,padx=5,pady=5) portEntry.pack(side=LEFT,padx=5,pady=5) btnConnect.pack(side=LEFT,padx=5,pady=5) etatLbl.pack(padx=5,pady=5) listeMsg.pack(fill=BOTH, expand=1,padx=5,pady=5) msgFrame.pack(fill=BOTH, expand=1,padx=5,pady=5) msgLbl.pack(side=LEFT,padx=5,pady=5) msgEntry.pack(fill=BOTH, expand=1,side=LEFT,padx=5,pady=5) msgSend.pack(side=LEFT,padx=5,pady=5) fenetre.mainloop() . Explications . Dans ce programme client, la majeure partie correspond au design de l&#39;interface graphique. Nous utilisons ici le widget Frame de TKinter permettant de créer des zones dans l&#39;interface dans laquelle la mise en page sera différente : . pack(side=LEFT,padx=5,pady=5) . permet de placer les composants les un à coté des autres dans les différents cadres. Les cadres eux même sont disposés avec la disposition par défaut c&#39;est à dire verticalement. . La problématique principale de ce programme est de gérer à la fois l&#39;écoute de messages en provenance du serveur et la réactivité de l&#39;interface graphique. En effet, la commande . message = liaison.recv(1024).decode(&quot;utf8&quot;) . est bloquante, ce qui signifie que quand le client est en attente d&#39;un message du serveur, il ne peut rien faire d&#39;autre. En particulier, il ne peut pas réagir aux événements en provenance de l&#39;utilisateur sur l&#39;interface graphique. L&#39;application est alors figée. . Pour se prémunir de ce problème, comme pour le serveur, nous devrons intégrer la commande de reception de message dans un Thread dédié qui tournera en parallèle de notre programme qui sera alors en capacité de gérer l&#39;interface graphique. . Pour ce faire, dès que le client se connecte au serveur on crée un thread par la commande . Thread(target=gestionClient) . qui sera en charge de receotionner les messages du serveur et de les afficher dans la zone de texte (Listbox) .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python8-Reseau-Threads.html",
            "relUrl": "/python/isn/2020/03/07/Python8-Reseau-Threads.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Python 7 - Découverte du réseau et serveur",
            "content": "Partie I : Adresses r&#233;seau . Sur un réseau, chaque ordinateur a une adresse appelée adresse IP (Internet Protocol). « Internet Protocol » est un mécanisme inventé pour le réseau internet mais qui est maintenant utilisé pratiquement tous les réseaux, y compris les petits réseaux domestiques. . Sur Internet, chaque machine connectée au réseau (ordinateur, téléphone, ...) possède une «adresse IP» unique. Cette adresse est constituée de 4 octets. . 1) Combien de machines peut-on connecter sur Internet ? . Répondez ici... . 2) Ce protocole (nommé ipv4) a manifestement atteint ses limites. Un nouveau protocole, nommé ipv6 est en cours de déploiement sur Internet. Il utilise des adresses de 128 bits. Combien de machines pourront être connectées simultanément grâce à ce nouveau protocole ? . Répondez ici... . 3) Ouvrir un terminal et taper à l’invite de commande la commande $ fbox{/sbin/ifconfig}$ . a. Quelle est votre adresse IP ? ... . b. Quelle est l&#39;adresse IP de votre voisin ? ... . c. Quelle partie votre adresse IP et celle de votre voisin ont-elle en commun ? ... . d. Vous pouvez tenter de communiquer avec votre voisin au travers de la commande $ fbox{ping Adresse_Ip.De.Votre.Voisin}$ dans le terminal. Qu’obtenez-vous ? . Partie II : Les noms sur internet . Les ordinateurs utilisent les adresses IP mais il est rare que les humains les retiennent : on préfère utiliser des noms. . Chaque ordinateur peut avoir un - ou plusieurs - nom. Dans un réseau il existe des ordinateurs dont la seule fonction est de tenir à jour les tables de correspondance entre les adresses IP et les noms dans une sorte d’annuaire semblable aux annuaires téléphoniques : les serveurs de noms (en abrégé DNS) . 1) Dans un terminal, taper $ fbox{ping lcs}$ puis $ fbox{ping google.fr}$ . . 2) Quelle est l’adresse IP du Lcs ? . Répondez ici ... . 3) Quelle est l’adresse IP de Google.fr ? . Répondez ici ... . Partie III : Principe de la communication Client/Serveur . Un ordinateur (le serveur) fait tourner en permanence un programme (un service) qui . attend que d’autres ordinateurs (les clients) le sollicitent | gère les échanges une fois la liaison établie | . 1) Citer des exemples de communications client/serveur dans vos usages quotidien des réseaux. . Votre réponse ici ... . 2) Pour ces exemples, décrire le rôle du serveur et du client. . Votre réponse ici . Partie IV : Ecrire un programme serveur en Python . Voici un programme serveur basique écrit en Python. On utilise ici la librairie socket qui gère la communication réseau en Python. . Exécutez cette cellule puis ouvrez le classeur Python7 - Reseau client pour exécuter la partie cliente. . Remarquez que quand le serveur tourne, le kernel python est monopolisé et ne permet plus l&#39;exécution d&#39;une autre cellule, d&#39;où la nécessité de changer de classeur pour la partie cliente. . Néanmoins, vous pourrez compléter la section suivante sur la compréhension du programme et répondre aux questions posées pendant que le serveur tourne. . Le programme serveur . from socket import * ### Mise en place du service ######## MON_IP ,PORT = &#39;127.0.0.1&#39; , 50000 service = socket(AF_INET, SOCK_STREAM) try: service.bind((MON_IP , PORT)) tourne = True except error : print(&quot;Impossible de démarrer le service.&quot;) tourne = False while tourne : print(&quot;Serveur prêt, en attente de requètes ...&quot;) service.listen(1) ### Mise en place d?une connexion ######## connexion, adresse = service.accept() print(&quot;Client connecté. : &quot;,adresse[0]) ### Dialogue avec le client ######## message = &quot;&quot; while message.upper() != &quot;FIN&quot; : message = input(&quot;moi &gt; &quot;) connexion.send(message.encode(&quot;utf8&quot;)) if message.upper() != &quot;FIN&quot; : message = connexion.recv(1024).decode(&quot;utf8&quot;) print(&quot;client &gt; &quot;, message) connexion.close() ch = input(&quot;&lt;R&gt;ecommencer &lt;T&gt;erminer ? &quot;) ch = ch[0].upper() if ch ==&#39;T&#39;: tourne = False service.close() . Compr&#233;hension du programme serveur . 1) Sur quelle adresse IP le serveur va t-il répondre ? . Votre réponse ... . 2) Une même machine peut héberger plusieurs services (programmes serveur). En effet le Lcs héberge un serveur web, un serveur de base de données, des services de messagerie, etc... . Pour éviter que ces services entrent en conflit, on utilise en plus de l’adresse IP un numéro de port qui peut être vu comme un canal de communication. Ce numéro de port est compris entre 1024 et 65535. . a. Quel numéro de port est utilisé dans le programme étudié ? ... . b. Changer le numéro de port sur le serveur. Que se passe t-il au niveau du client ? ... . c. Adapter également le numéro de port sur le client. Le programme fonctionne t-il à nouveau ? ... . 3) Quelle commande est responsable sur le serveur de l’envoi du message au client ? . Votre réponse ... . 4) Écrire en langage naturel l’algorithme correspondant au serveur . Votre réponse ... . 5) Quel message taper coté client ou serveur pour mettre fin à la communication ? . Votre réponse ... . A vous de jouer : Jeu du juste prix en r&#233;seau . L’objectif de l’activité est de réaliser un jeu de juste prix en réseau. . 1) Décrire le rôle du serveur et du client. . Votre réponse ... . 2) Écrire l’algorithme en langage naturel d’un jeu de juste prix en réseau. Vous devrez pour cela écrire l’algorithme du serveur et du client. . 3) en vous aidant des commandes vues dans l’exemple étudier, modifier le programme serveur étudié afin de programmer un jeu de juste prix en réseau. On pourra essayer de deviner un nombre entier entre 1 et 100. . # Votre programme ici... .",
            "url": "https://fastpages.fast.ai/isn/socket/2020/03/07/Python7-Reseau-serveur.html",
            "relUrl": "/isn/socket/2020/03/07/Python7-Reseau-serveur.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Le réseau en Python côté client",
            "content": "Avant d&#39;ouvrir ce classeur, vous devrez avoir traité le classeur Python 7 - Découverte du réseau et serveur jusqu&#39;à la partie IV. . Voici un programme client basique écrit en Python. On utilise toujours la librairie socket qui gère la communication réseau en Python. . Exécutez la cellule suivante cellule après avoir lancé le serveur sur le classeur Python 7 - Découverte du réseau et serveur, puis rendez-vous dans l&#39;onglet serveur pour initier la discussion. . Remarquez que quand le client tourne, le kernel python est monopolisé et ne permet plus l&#39;exécution d&#39;une autre cellule, d&#39;où la nécessité d&#39;avoir deux classeurs distincts. . Néanmoins, vous pourrez compléter la section suivante sur la compréhension du programme et répondre aux questions posées pendant que le client tourne. . Le programme client . from socket import * SERVEUR , PORT = &#39;127.0.0.1&#39; , 50000 liaison = socket(AF_INET, SOCK_STREAM) try: liaison.connect((SERVEUR, PORT)) message=&quot;&quot; except error: print(&quot;La connexion a échoué.&quot;) message=&quot;FIN&quot; # serveur et service while message.upper() != &quot;FIN&quot; : message = liaison.recv(1024).decode(&quot;utf8&quot;) print(&quot;serveur &gt;&quot;, message) if message.upper() != &quot;FIN&quot; : message = input(&quot;moi &gt; &quot;) liaison.send(message.encode(&quot;utf8&quot;)) print(&quot;Connexion terminée.&quot; ) liaison.close() . Compr&#233;hesion du programme client . 1) Que se passe t-il si vous lancez le client avant d&#39;avoir lancé le serveur ? . Votre réponse ... . 2) Quelle commande est responsable sur le client de l’envoi du message au serveur ? . Votre réponse ... . 3) Écrire en langage naturel l’algorithme correspondant au programme client . Votre réponse ... . A vous de jouer : Jeu du juste prix en r&#233;seau . Ecrire ci-dessous le code client du jeu du juste prix . # Votre programme ici... .",
            "url": "https://fastpages.fast.ai/isn/socket/2020/03/07/Python7-Reseau-client.html",
            "relUrl": "/isn/socket/2020/03/07/Python7-Reseau-client.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Programmation Orientée Objet - Partie 2",
            "content": "Faisons nos classes ! . Un exemple valant mieux qu&#39;un long discours, supposons que je sois en train de développer un programme permettant de travailler sur les polynômes. . Je peux définir un objet représentant un polynôme en général. On peut choisir de représenter les coefficients par une liste de nombres, qui sera donc une propriété de notre classe et définir une méthode permettant de calculer le degré du polynôme. . Avec ces conventions, la liste [1,2,3] représente le polynôme $1+2x+3x^2$. . Exemple de classe . Voici le code définissant la classe Polynome avec une méthode pour calculer le degré et une autre pour calculer une valeur en un réel $x$ . class Polynome : &quot;&quot;&quot;Représentation d&#39;un polynome à coefficients réels&quot;&quot;&quot; def __init__(self, liste_coeffs = [0]) : &quot;&quot;&quot;Initialisation des coeffs, polynome nul par défaut&quot;&quot;&quot; self.coeffs = liste_coeffs def deg(self) : &quot;&quot;&quot;Degré du polynome&quot;&quot;&quot; return len(self.coeffs)-1 def valeur(self, x) : &quot;&quot;&quot;Calcule P(x)&quot;&quot;&quot; val = self.coeffs[0] power = 1 for k in range(1, len(self.coeffs)) : power = power * x val = val + self.coeffs[k]*power return val . Explications et remarques . Par convention, on mettra une majuscule à la première lettre du nom d&#39;une classe, pour les différencier des autres variables, fonctions qui, elles, débuteront toujours par une lettre minuscule. | La première méthode définie ci-dessous porte le nom spécial __init__() : il s&#39;agit de la méthode constructeur : elle est automatiquement exécutée lors de la création d&#39;un nouvel objet de type Polynome (voir plus loin). | Dans cette méthode, nous déclarons une propriété à notre classe par l&#39;affectation self.coeffs = . Une propriété est une variable qui est attachée à la classe, d&#39;où le recours à self pour référencer l&#39;objet lui-même. En général, ces propriétés sont initialisées dans la méthode __init__(). | Chacune des trois méthodes possède comme premier argument le paramètre spécial self : il représente l&#39;objet &quot;lui-même&quot; dont on est en train de définir une méthode. La référence à cet objet est obligatoire : Toute déclaration de méthode doit contenir self comme premier paramètre. | On le voit sur cet exemple, une méthode n&#39;est pas grand chose de plus qu&#39;une fonction telle que vous la conaissez ! la manière de la déclarer dans une classe est assez similaire - au paramètre self près. | . L&#39;objet Polynome() que nous venons de créer possède . une propriété : la liste coeffs | deux méthodes en plus de __init()__ (qui elle est systématique) : deg() et valeur() | . L&#39;accès à la propriété coeffs de notre classe se fait au travers de la variable self.coeffs . Utilisons notre nouvelle classe . p = Polynome([0, 2, 3, 1]) print(&quot;P est de degré &quot;,p.deg()) print(&quot;P(10)=&quot;,p.valeur(10)) print(&quot;Les coeffs de P sont &quot;,p.coeffs) . Explications et remarques . Lors de la création d&#39;un nouveau polynôme, on appelle la classe Polynome() avec comme argument la liste des coefficients. Cela a pour effet d&#39;exécuter la méthode constructeur __init__() de la classe Polynome() qui crée la propriété coeffs correspondant. | Pour exécuter une méthode associée à l&#39;objet p, on utilise la notation pointée et on omet l&#39;argument self : celui-ci n&#39;est précisé que lors de la définition d&#39;une méthode, mais pas lors de son exécution. | . Un peu de magie : surcharge de fonctions pr&#233;d&#233;finies . Affichage d&#39;un polyn&#244;me . Pour afficher un polynôme, la commande print() ne donne pas le résultat attendu : . print(p) . Pour parvenir au résultat attendu, on peut surcharger la fonction print(). Plus précisément, on peut indiquer à Python comment convertir un polynôme en chaîne de caractères, ce que fera ensuite automatiquement la commande print(). . Pour cela, vous allez créer la méthode __str__() dans la définition de la classe Polynome(). Vous renverrez une chaîne de caractère bien formatée représentant le polynôme en respectant les règles suivantes . vous partirez du terme de plus petit degré vers le terme de plus haut degré. | la variable se nommera &#39;X&#39; (en majuscule) | vous mettrez des espaces autour des &#39; + &#39; et des &#39; - &#39; entre chaque termes | vous n&#39;écrirez pas &#39; + -2X &#39; par exemple mais &#39; -2X&#39; | vous n&#39;écrirez pas les termes nuls | . bref, tout ce qui va dans le sens d&#39;une écriture naturelle. . Exemple : pour le polynôme [0, 2, -3, 1] vous renverrez &#39;2X - 3X^2 + X^3&#39; . class Polynome : &quot;&quot;&quot;Représentation d&#39;un polynome à coefficients réels&quot;&quot;&quot; def __init__(self, liste_coeffs = [0]) : &quot;&quot;&quot;Initialisation des coeffs, polynome nul par défaut&quot;&quot;&quot; self.coeffs = liste_coeffs def deg(self) : &quot;&quot;&quot;Degré du polynome&quot;&quot;&quot; return len(self.coeffs)-1 def valeur(self, x) : &quot;&quot;&quot;Calcule P(x)&quot;&quot;&quot; val = self.coeffs[0] power = 1 for k in range(1, len(self.coeffs)) : power = power * x val = val + self.coeffs[k]*power return val def __str__(self) : &quot;&quot;&quot; Convertit le polynome en chaine pour affichage&quot;&quot;&quot; # YOUR CODE HERE raise NotImplementedError() . p = Polynome([0, 2, -3, 1]) assert p.__str__() == &#39;2X - 3X^2 + X^3&#39; print(p) . Addition de polyn&#244;mes . Soit les polynômes $P(x)=2x+3x^2+x^3$ et $Q(x)=x^6$. Pour obtenir le polynôme $P+Q$, on aimerait utiliser simplement l&#39;opérateur &#39;+&#39;. Mais voilà ce qui arrive . p = Polynome([0, 2, 3, 1]) q = Polynome([0, 0, 0, 0, 0, 0, 1]) s = p + q print(s) . Là encore, pour résoudre ce problème, on peut surcharger l&#39;addition en définissant la méthode spéciale __add__(), c&#39;est-à-dire apprendre à Python comment on additionne deux polynômes. . Completez la classe Polynomes() de manière à implémenter la somme de 2 polynômes . class Polynome : # YOUR CODE HERE raise NotImplementedError() . Essayons à nouveau l&#39;addition de nos polynômes . p = Polynome([0, 2, 3, 1]) q = Polynome([0, 0, 0, 0, 0, 0, 1]) s = p + q print(s) assert s.coeffs == [0, 2, 3, 1, 0, 0, 1] . Autres m&#233;thodes sp&#233;ciales . On peut également définir des méthodes __sub__() pour la soustraction, __mul__() pour la multiplication, __truediv__() pour la division, etc... . D&#39;autres méthodes spéciales existent : la liste complète est disponible dans la documentation de Python. . Le concept d&#39;h&#233;ritage . L&#39;un des grands avantages des objets est l&#39;héritage. Cela permet de personaliser une classe en héritant des propriétés et méthodes d&#39;une autre classe. . Nous allons en voir un exemple en créant une classe Trinome() pour le cas particulier des polynômes du second degré. En effet, un polynome du second degré étant un cas particulier de polynome, nous ne voulons pas réécrire tout le code que nous venons de créer, notamment pour l&#39;affichage et l&#39;addition. Néanmoins, pour le trinome, nous savons calculer les racines et nous souhaitons donc enrichir notre classe Trinome() avec une méthode suplémentaire appelée racines(). Celle-ci utilisera une nouvelle propriété delta créée lors de l&#39;initialisation de notre classe. . Pour éviter de réécrire toutes les fonctions propres aux polynomes, nous allons faire hériter notre classe Trinome() de la classe Polynomes(). . Regardez plutôt avec quelle facilité à présent nous allons créer notre classe Trinome() : . class Trinome(Polynome) : &quot;&quot;&quot; Représentation des polynomes du second degré&quot;&quot;&quot; def __init__(self, liste_coeffs=[0,0,1]) : &quot;&quot;&quot; Initialisation d&#39;un trinome, x^2 par défaut &quot;&quot;&quot; Polynome.__init__(self, liste_coeffs) # On appelle le constructeur parent self.a = liste_coeffs[2] self.b = liste_coeffs[1] self.c = liste_coeffs[0] self.delta = self.b ** 2 - 4 * self.a * self.c def racines(self) : &quot;&quot;&quot; Calcule les racines éventuelles d&#39;un trinome &quot;&quot;&quot; if self.delta &lt; 0 : return None elif self.delta == 0 : return -self.b / (2 * self.a) else : return ( (- self.b - sqrt(self.delta)) / (2 * self.a) , (- self.b + sqrt(self.delta)) / (2 * self.a) ) . Explications et remarques . La méthode constructeur __init__() de la classe fille doit obligatoirement appeler la méthode constructeur de sa mère. C&#39;est le rôle ici de la ligne 6. | On définit ensuite les nouveaux attributs propres aux objets de la classe Trinome(). | . Utilisation de la nouvelle classe . Testons maintenant notre nouvelle classe Trinome(). . Cette classe ayant été explicitement définie comme fille de la classe Polynome(), elle a hérité de toutes les méthodes et de tous les attributs de celle-ci. . On peut donc exécuter le code suivant : . t1 = Trinome([2, -3, -5]) print(t1) print(&quot;Delta=&quot;,t1.delta) print(&quot;Racines&quot;,t1.racines()) print(t1.valeur(0.4)) . A vous de jouer . Créer une classe pour représenter les nombre rationnels. . Vous définirez les méthodes permettant d’additionner, de soustraire, de multiplier et de diviser deux rationnels, ainsi qu&#39;une méthode permettant un affichage sous la forme a/b. . # YOUR CODE HERE raise NotImplementedError() . # Tester votre classe p=Rationnel(2,3) q=Rationnel(3,4) print (&quot;p=&quot;,p) print (&quot;q=&quot;,q) print(&quot;p+q=&quot;,p+q) print(&quot;p-q=&quot;,p-q) print(&quot;p*q=&quot;,p*q) print(&quot;p/q=&quot;,p/q) assert (p/q).p==8 assert (p*q).q==12 . Exercice facultatif . Pour la gestion d&#39;une bibliothèque, créer une classe Document() définissant une propriété booléen sorti, une propriété titre sous forme de chaîne de caractère, une méthode prete() et une méthode retourne() qui changent la valeur de la propriété sorti. . Créer ensuite une classe fille Livre() qui possédera en plus une propriété auteur et une propriété nombre_de_pages ainsi qu&#39;une classe fille Dvd() avec une propriété duree en minutes. . Attention, toutes les propriétés doivent être initialisées par la méthode constructeur de la classe ! . # YOUR CODE HERE raise NotImplementedError() . .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python6-Programmation-Orientee-Objet-(POO)-Partie-2.html",
            "relUrl": "/python/isn/2020/03/07/Python6-Programmation-Orientee-Objet-(POO)-Partie-2.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "Programmation Orientée Objet",
            "content": "Objets et POO sont au centre de la manière Python fonctionne. Vous n&#39;êtes pas obligé d&#39;utiliser la POO dans vos programmes - mais comprendre le concept est essentiel pour devenir plus qu&#39;un débutant. Entre autres raisons parce que vous aurez besoin d&#39;utiliser les classes et objets fournis par la librairie standard. . De plus, avant d&#39;aborder la programmation d&#39;interfaces graphiques qui utilisent abondamment les objet, des notions autour de la POO seront utiles. . Petit historique . La programmation en tant que telle est une matière relativement récente. Etonnament la programmation orientée objet remonte aussi loin que les années 1960. Simula est considéré comme le premier langage de programmation orienté objet. . Les années 1970 voient les principes de la programmation par objet se développent et prennent forme au travers notamment du langage Smalltalk . À partir des années 1980, commence l&#39;effervescence des langages à objets : Objective C (début des années 1980, utilisé sur les plateformes Mac et iOS), C++ (C with classes) en 1983 sont les plus célèbres. . Les années 1990 voient l&#39;âge d&#39;or de l&#39;extension de la programmation par objet dans les différents secteurs du développement logiciel, notemment grâce à l&#39;émergence des systèmes d&#39;exploitation basés sur une interface graphique (MacOS, Linux, Windows) qui font appel abondamment aux principes de la POO. . Nous verrons sur le prochain classeur comment une interface graphique peut se programmer au moyens d&#39;objets (fenêtre, boutons, textes, champs de saisie etc...). . Programmation proc&#233;durale . La programmation procédurale est celle que vous avez utilisé jusqu&#39;à maintenant : cela consiste à diviser votre programme en blocs réutilisables appelés fonctions. . Vous essayez autant que possible de garder votre code en blocs modulaires, en décidant de manière logique quel bloc est appelé. Cela demande moins d’effort pour visualiser ce que votre programme fait. Cela rend plus facile la maintenance de votre code – vous pouvez voir ce que fait une portion de code. Le fait d’améliorer une fonction (qui est réutilisée) peut améliorer la performance à plusieurs endroits dans votre programme. . Vous avez des variables, qui contiennent vos données, et des fonctions. Vous passez vos variables à vos fonctions – qui agissent sur elles et peut-être les modifient. L&#39;inteaction entre les variables et les fonctions n&#39;est pas toujours simple à gérer comme on l&#39;a vu dans le classeur précédent ! ou bien une variable est locale et n&#39;est pas visible des autres fonction, ou bien une variable est globale et toutes les fonctions sont suceptibles d&#39;y avoir accès. . On touche ici aux limites de la programmation procédurale, lorsque le nombre de fonctions et de variables devient important. . Mais qu&#8217;est ce qu&#8217;un Objet ? . En Python les éléments de base de la programmation que nous avons rencontré comme les chaînes de caractères, ou les listes sont des objets. Ils possèdent des propriétés - variables qui stockent des valeurs - et des méthodes - fonctions qui agissent sur ces valeurs. . Voici un petit exemple d&#39;objet qui vous est déjà familier : . liste=[3,5,4,2,8,5,4] . liste.sort() liste . Ici nous avons fait appel à la méthode sort() de l&#39;objet liste afin de trier notre liste. . Mais dans nos projets futurs, nous pouvons avoir envie de définir nos propres objets, c&#39;est à dire d&#39;enrichir la bibliothèque de types built-in standard de Python avec des objets que nous façonnerons selon nos besoins. C&#39;est la qu&#39;intervient la notion de classe. . Cr&#233;ation d&#39;une classe . En premier exemple, supposons que nous voulions travailler sur un logiciel de géométrie. Nous avons besoin d&#39;un objet point qui est un nouveau type d&#39;objet contenant deux informations : . l&#39;abscisse de notre point | l&#39;ordonnée de notre point. | . Ces deux informations sont ce que nous appelons en POO des attributs ou des propriétés. . Assez de discours, créons notre classe : . class Point(): abscisse=0 ordonnee=0 . Et c&#39;est tout !!! nous avons créé une classe contenant deux propriétés une abscisse et une ordonnée toutes deux initialisées à 0. . Comment ça marche ? . print (Point.abscisse) print (Point.ordonnee) Point.abscisse=2 print (Point.abscisse) . Ca a l&#39;air trè simple ! En réalité, nous allons vite être limité si nous n&#39;utilisons que cette classe. En effet, nous créé un objet classe Point qui contient deux informations. Mais dans notre logiciel de géométrie, nous voulons créer plusieurs points !! . C&#39;est le moment de parler de la notion d&#39;instance. Une instance est un objet que nous créons en mémoire à partir d&#39;une classe. Voici comment : . p1=Point() p2=Point() p1.abscisse=2 p2.ordonnee=3 print (p1.abscisse,p1.ordonnee) print (p2.abscisse,p2.ordonnee) . Nous y voila ! J&#39;ai donc à présent la possibilité de créer autant de points que je veux. Il faut bien distinguer la notion de classe et la notion d&#39;instance : . une classe peut être vue comme le prototype permettant de créer nos instances | les instances sont les véritables objets que nos manipulerons, créés à partir de notre prototype. | . Pour bien comprendre ce phénomène, prenons une comparaison avec le monde des contructeurs automobile : Lorsqu&#39;un contructeur va sortir une nouvelle voiture, il ne va pas immédiatement produire en série plusieurs millions de véhicules. Il va tout d&#39;abord élaborer un prototype : . d&#39;abord sur papier, il va dessiner sa nouvelle voiture, les formes, les équipements, chaque pièce de sa voiture etc... | ensuite il va réaliser une maquette, la tester en soufflerie pour affiner sa forme | enfin, il va réaliser un modèle fonctionnelle qu&#39;il testera sur route : c&#39;est le prototype. | . C&#39;est ce travail que nous réaliserons lorsque nous construirons notre classe. Construire une classe c&#39;est construire un prototype unique. . Une fois notre prototype terminé, notre constructeur va passer à la production en série. Il va créer des millions d&#39;instances de notre prototype qui sont les voitures créées en série à partir de notre prototype. Chaque instance pourra être personnalisé à partir de notre prototype : en effet chaque nouvelle voiture possèdera sa propre couleur qui n&#39;est pas forcément celle de notre prototype, possèdera des options spécifique (gps, toit ouvrant etc...). . Retenez donc cette comparaison : . la classe correspond à notre prototype | l&#39;instance correspond à la voiture produite en série à partie de notre protptype (la classe). | . Notion de m&#233;thode . Nous avons créé notre objet point qui se caractérise par deux propriétés : abscisse et ordonnée. Mais si ce n&#39;était que cela, pourquoi ne pas utiliser un tuple ! Nous allons donc enrichir notre classe (le prototype servant de modèle pour créer nos points) en y ajoutant des fonctions uniques : les méthodes. . Nous nous intéressons par exemple à la distance séparant notre point de l&#39;origine du repère. Nous souhaiterions que notre objet point possède une méthode pour nous renvoyer cette information. Une méthode n&#39;est autre qu&#39;une fonction intégrée à un objet. Voici comment procéder. Nous allons modifier notre classe : . from math import sqrt # On a besoin de la racine carrée ! class Point(): abscisse=0 ordonnee=0 def distanceAZero (self): return sqrt (self.abscisse**2+self.ordonnee**2) . Regardons le résultat : . p1=Point() p1.abscisse=3 p1.ordonnee=4 print(p1.distanceAZero()) . Et voila ! notre objet point commence à prendre tournure : il possède . deux propriétés : abscisse et ordonnee | une méthode : distanceAZero() | . Cette méthode est une fonction encapsulée dans notre objet qui agit sur ses propriétés et effecture le travail demandé. Revenons sur la déclaration de cette méthode : . Une méthode se déclare comme une c=fonction classique à l&#39;intérieur de la classe à ceci près qu&#39;elle prend toujours en premier argument l&#39;instance sur laquelle elle agit. Par convention, nous nommons cette instance self. . Nous voyons sur l&#39;exemple de la distanceAZero l&#39;avantage de disposer de cette information d&#39;instance : nous voulons que la méthode agisse sur l&#39;instance depuis laquelle elle a été appelée et non sur les propriétés de la classe (le prototype). La variable self nous permettra de connaître l&#39;instance sur laquelle nous travaillons. . Reste à décrire la syntaxe un peu étrange de cette fonction : Si self est le premier argument, pourquoi ne le trouve t-on pas lors de l&#39;appel de la fonction distanceAZero() ? Voici l&#39;explication. . En réalité, nous devrions passer l&#39;appel à la méthode de cette manière : . print(Point.distanceAZero(p1)) . Ainsi nous voyons bien que distanceAZero accepte bien l&#39;instance sur laquelle elle agit en premier paramètre et que c&#39;est une fonciton intégrée à la classe Point. Néanmoins cette syntaxe est très lourde ! Imaginez taper la ligne suivante à la place de . liste.append(5) . list.append(liste,&#39;autre syntaxe&#39;) # Et pourtant cela foncitonne ! print(liste) . Dans la pratique, une méthode sera toujours appelée depuis une instance et le premier paramètre sera omis puisque il est donnée justement par l&#39;instance qui appelle. Syntaxiquement, les deux formes . Point.distanceAZero(p1) . et . p1.distanceAZero() . sont équivalentes. Nous utiliserons systématiquement la seconde forme. . A vous de jouer . Vous allez enrichir la classe Point en ajoutant . une propriété nom contenant le nom du point (par défaut &#39;A&#39;) | une méthode distance(p) qui affichera untexte du type &quot;La distance AB=5&quot; avec bien sur les vrais noms des points et la vraie distance | retournera la distance du point au point p passé en argument. | . | . Attention, je rappelle qu&#39;une méthode prend toujours en premier argument self. . from math import sqrt # On a besoin de la racine carrée ! # Redéfinissez votre classe # YOUR CODE HERE raise NotImplementedError() . Pour tester votre classe, validez la cellule suivante. La réponse doit être : . La distance AB = 5.0 Out[...]:5.0 . p1=Point() p1.abscisse=2 p1.ordonnee=3 p2=Point() p2.abscisse=-1 p2.ordonnee=7 p2.nom=&#39;B&#39; assert p1.distance(p2)==5.0 . Surcharge des op&#233;rateurs . On peut améliorer un peu le comportement de notre classe en initialisant de manière plus propre les différentes propriétés. En effet, pour le moment, pour créer un point avec le bon nom et les coordonnées souhaitées, nous avons besoin de 4 lignes ! p1=Point() p1.abscisse=2 p1.ordonnee=3 p1.nom=&#39;P&#39; . On peut faire beaucoup mieux en surchargeant la méthode init() qui est une méthode spéciale appelée automatiquement lors de la création d&#39;ue instance. Cette méthode prend . en premier paramètre self bien évidemment! | en paramètres optionnels, des paramètres passés à la classe lors de la création. | . class Point(): def __init__(self,x,y,nom): self.abscisse=x self.ordonnee=y self.nom=nom def distanceAZero (self): return sqrt (self.abscisse**2+self.ordonnee**2) def distance(self, p): d=sqrt((self.abscisse-p.abscisse)**2+(self.ordonnee-p.ordonnee)**2) print (&quot;La distance &quot;,self.nom+p.nom,&quot;=&quot;,d) return d . Regardons comment créer notre point : . p1=Point(2,3,&#39;A&#39;) p2=Point(-1,7,&#39;B&#39;) p1.distance(p2) . C&#39;est quand même bien mieux ! Mais tout n&#39;est pas parfait. Observez ce qui se passe si je veux afficher les coordonnées d&#39;un point. Je peux avoir envie de faire cela : . print(p1) # beark . A vous de jouer . Il existe une autre méthode magique - en réalité, il y en a environs 80 - permettant de redéfinir le comportement des opérateurs intégrés à Python. Vous allez créer une méthode nommée str() qui . ne prendra pas d&#39;argument autre que self bien sur | retournera une chaîne de caractère du type &quot;A(2;3)&quot; | . Pour construire votre chaîne, vous pourrez utiliser la concaténation de chaines de caractères au moyen de l&#39;opérateur +. Regardez l&#39;exemple : . x,y=2,3 chaine=&quot;A&quot;+str(x)+&quot;; etc...&quot; # etc... vous voyez le principe print(chaine) . # A vous de jouer # YOUR CODE HERE raise NotImplementedError() . # Et voila la magie qui s&#39;opère ! p1=Point(2,3,&#39;A&#39;) print(p1) assert p1.__str__()==&#39;A(2;3)&#39; . Et voila, bien venue dans le monde merveilleux des objets. . En seconde partie, nous allons prendre un exemple plus sofistiqué sur les polynomes pour approfondir les notions que nous avons introduites dans ce classeur. . A bientôt ! .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python6-Programmation-Orientee-Objet-(POO)-Partie-1.html",
            "relUrl": "/python/isn/2020/03/07/Python6-Programmation-Orientee-Objet-(POO)-Partie-1.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Les ensembles (set)",
            "content": "# créer un un ensemble ensemble = {1,5,9,5,1,2,4} ensemble . Comme on peut le voir, les éléments en doubles dans ensemble ont été éliminés et l&#39;ordre affiché n&#39;est pas celui dans lequel les éléments ont été saisis. . # essayons quelque chose... ensemble[3] . l&#39;accès aux éléments par indice comme pour les listes n&#39;est pas possible, cela n&#39;a tout simpliement pas de sens. . Conversion list &lt;-&gt; set . liste = [1,5,9,5,1,2,4] ensemble = set(liste) ensemble . ensemble = {1, 9, 5, 4, 2} liste = list(ensemble) liste . M&#233;thodes sur les ensembles . ajout et retrait : add et remove . ensemble = {1, 9, 5, 4, 2} ensemble.add(18) ensemble.remove(9) ensemble . Attention de bien tester si un élément est dans l&#39;ensemble avant la suppression car sinon... . ensemble.remove(3) . et du coup ... . tester si un &#233;l&#233;ment est pr&#233;sent dans un ensemble : in . 3 in ensemble . 18 in ensemble . Longueur et ensemble vide . # l&#39;ensemble vide est noté {} ou set() vide = set() vide.add(3) vide.remove(3) # Calculer le nb d&#39;éléments d&#39;un ensemble len(vide) . Application . Créer une fonction ensembleCarres prenant en paramètre un entier $n$ e renvoyant un ensemble contenant les carrés des entiers de 1 à $n$ . def ensembleCarres(n): # YOUR CODE HERE raise NotImplementedError() . ec = ensembleCarres(10) assert len(ec)==10 assert 64 in ec . Créez une liste l de carrés jusqu&#39;à un million. | Créez un ensemble s de carrés jusqu&#39;à un million. | Recherchez si $874466246641$ est un carré | . # YOUR CODE HERE raise NotImplementedError() . Comparez les temps de recherche d&#39;un même nombre dans l&#39;ensemble et dans la liste. . %%time assert 874466246641 in s . %%time assert 874466246641 in l . quelques autres m&#233;thodes sur les set . s.isdisjoint(s2) s.issubset(s2) s.issuperset(s2) s &lt;= s2 : inclusion (pareil avec s &gt;= s2). s &lt; s2 : inclusion stricte (pareil avec s &gt;= s2). set.union(s1, s2, s3) : renvoie la réunion de plusieurs sets. set.intersection(s1, s2, s3) : renvoie l&#39;intersection de plusieurs sets . Exercice . Créer une fonction ensembleCubes prenant en paramètre un entier $n$ e renvoyant un ensemble contenant les cubes des entiers de 1 à $n$ . def ensembleCubes(n): # YOUR CODE HERE raise NotImplementedError() . assert 27 in ensembleCubes(10) . En déduire en une ligne de python combien de nombres entre 1 et 100 sont à la fois des carrés et des cubes . # Tapez votre ligne dans la cellule ci-dessous . # Attention, pas plus d&#39;une ligne de Python !! .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python5-Les-ensembles.html",
            "relUrl": "/python/isn/2020/03/07/Python5-Les-ensembles.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post17": {
            "title": "Les dictionnaires",
            "content": "Les dictionnaires sont des objets pouvant en contenir d&#39;autres, un peu comme des listes. . Cependant, au lieu d&#39;héberger des informations dans un ordre précis, ils associent chaque valeur contenue à une clé (qui peut être une chaîne de caractère ou simplement un nombre). . Voyons tout de suite un exemple : . coeffBacS={&quot;ISN&quot;:2,&quot;Maths&quot;:7} . Dans l&#39;exemple ci-dessus, nous avons créé un dictionnaire coeffBacS. Nous voyons tout de suite que : . le caractère servant à délimiter le dictionnaire est l&#39;accolade { }, ce qui le distingue des listes délimitées par des crochets. | Il contient deux valeurs : 2 et 7 | Il contient deux clés : &quot;ISN&quot; et &quot;Maths&quot; | . Acc&#233;der &#224; une valeur du dictionnaire . Contrairement aux listes ou on accède aux valeurs par la position dans la liste, on accède aux valeurs du dictionnaire par l&#39;intermédiaire des clés. Regardez l&#39;exemple ci-dessous : . coeffBacS[&quot;ISN&quot;] . La ressemblance avec les listes pour accéder aux données est assez frappante. . Attention à bien utiliser une clé qui a été définie, sinon... . coeffBacS[&quot;MATHS&quot;] . Ici la clé MATHS n&#39;existe pas. En effet le système est sensible aux majuscules ! . Savoir si une cl&#233; existe dans un dictionnaire . Pour éviter ce type d&#39;erreur, on peut tester l&#39;existance d&#39;une clé par le mot clé Python in . &quot;MATHS&quot; in coeffBacS . &quot;ISN&quot; in coeffBacS . Ajouter des donn&#233;es &#224; un dictionnaire . L&#39;ajout de données se fait très simplement : . coeffBacS[&quot;Philo&quot;]=3 . Les clés peuvent être de type différents, ainsi que les données : . coeffBacS[&quot;Philo&quot;] . Remarque : les clés ne sont pas nécessairement du type chaîne de caractère. Tout type non mutable peut servir de clé. On peut très bien utiliser un nombre comme clé : . # on crée un dictionnaire vide autreDico=dict() # on définit des clés sous forme de nombres autreDico[3.14] = &quot;pi&quot; autreDico[2.718] = &quot;e&quot; # il est possible de mélanger les types de clés # mais ce n&#39;est pas forcément une bonne idée ! autreDico[&quot;pi&quot;] = 3.1415 . autreDico[3.14] . autreDico[&quot;pi&quot;] . Parcourir un dictionnaire . Pour parcourir un dictiionnaire, on va utiliser les méthodes . keys() pour récupérer la liste des clés | values() pour récupérer la liste des valeurs | . Par exemple, affichons toutes les valeurs contenues dans notre dictionnaire . coeffBacS.values() . et de même pour les clés : . coeffBacS.keys() . Pour parcourir un dictionnaire par clés, il suffit de faire une boucle du type : . for matiere in coeffBacS.keys(): print(matiere , &quot; coeff &quot;, coeffBacS[matiere]) . Complétons notre dictionnaire .... . coeffBacS[&quot;Francais Oral&quot;]=2 coeffBacS[&quot;Physique Chimie&quot;]=6 coeffBacS[&quot;SVT&quot;]=6 coeffBacS[&quot;HGéo&quot;]=3 coeffBacS[&quot;LV1&quot;]=3 coeffBacS[&quot;TPE&quot;]=2 . Supprimer une cl&#233; . On peut supprimer une clé (et sa valeur correspondante) d&#39;un dictionnaire en utilisant, au choix, la méthode del ou la méthode pop. . coeffBacS.pop(&quot;Physique Chimie&quot;) . coeffBacS[&quot;Physique Chimie&quot;] . A vous de jouer... . Ecrire une fonction bacS prenant en paramètre un dictionnaire dont les valeurs sont les coefficients et qui renvoie la somme des coefficients des matières du bac. . def bacS(dico): # YOUR CODE HERE raise NotImplementedError() . dicoTest = coeffBacS={&quot;ISN&quot;:2,&quot;Maths&quot;:7, &quot;Francais Oral&quot;:2, &quot;Physique Chimie&quot;:6, &quot;SVT&quot;:6, &quot;HGéo&quot;:3, &quot;LV1&quot;:3, &quot;TPE&quot;:2} assert bacS(dicoTest) == 31 . Exercice . Ecrire une fonction dicoCarres prenant en paramètre un entier $n$ et renvoyant un dictionnaire dont les clés sont les entiers de 1 à $n$ et les valeurs sont les carrés de ces nombres . def dicoCarres(n): # YOUR CODE HERE raise NotImplementedError() . d = dicoCarres(10) assert d[5] == 25 . Ecrire une fonction inverseDico prenant en paramètre un dicitonnaire d et renvoyant un dictionnaire dont les clés sont les valeurs de d et les valeurs sont les clés correspondantes. . On supposera que les clés et les valeurs sont uniques (comme dans notre dictionnaire des carrés) pour simplifier la tâche. . def inverseDico(d): # YOUR CODE HERE raise NotImplementedError() . d = dicoCarres(10) i = inverseDico(d) assert i[64] == 8 .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python5-Les-dictionnaires.html",
            "relUrl": "/python/isn/2020/03/07/Python5-Les-dictionnaires.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post18": {
            "title": "Utilisation avancée des variables",
            "content": "En Python, les variables sont crées automatiquement à leur première utilisation. Pour créer une variable, il suffit donc de l’utiliser en l’affectant une première fois, c’est à dire d’écrire nom_variable=valeur_de_la_variable. Une variable peut prendre n’importe quel nom, tant qu’elle respecte les règles suivantes : . Son nom commence de préférence par une lettre minuscule (a à z) ou majuscule (A à Z), ou bien par le caractère souligné (_) | Pour la suite de son nom, on peut utiliser les lettres minuscules et majuscule, le souligné et un chiffre (0 à 9) | Il faut éviter de préférence d’utiliser un mot réservé (commande Python) | . Avant de commencer, validez la cellule suivante qui nous permettra d&#39;accéder à un outil très pratique : Python tutor. . from metakernel import register_ipython_magics register_ipython_magics() . Affectations - rappels . a=7 # Affectation simple x=y=7 # Affectation multiple z,t=&quot;toto&quot;,8 # Affectation en parallèle . print(a) print(x,y) print(z,t) . Variables locales - Variables globales . Variables locales . Une variable locale est une variable définie à l’intérieur d’une fonction. Elle n’est utilisable qu’à l’intérieur de celle-ci, le reste du programme ignorant totalement son existence. . Cet exemple illustre le mécanisme de variable locale et de passage de paramètre. La variable locale varLoc est utilisable à l’intérieur de la fonction maFonction et remplit son rôle. . def maFonction(param): varLoc=4 varLoc=varLoc+param print(varLoc) maFonction(5) . Néanmoins, cette variable n&#39;a plus d&#39;existance à l&#39;extérieur de la fonction. Exécutez le code suivant et trouver dans le message d&#39;erreur ce qui prouve que la variable locale est détruite en sortant de la fonction. . maFonction(3) print(varLoc) . Variables globales . Il existe des cas ou on souhaite qu&#39;une variable soit persistante tout au long de la vie du programme, quelque soit la fonction qui l&#39;utilise. C&#39;est ce qu&#39;on appelle une variable globale. . Il faut être assez prudent dans l&#39;utilisation de ces variables : une trop grande quantité de variables globales rend le programme difficile à lire et à maintenir. C&#39;est une technique de programmation peu élégante. . On préfère en général avoir recours à des objets (voir le classeur sur la programmation orientée objet). . Une variable globale est définie dans le programme principal (souvent au début dans la section d’initialisa- tion). Elle est par défaut accessible en lecture seule dans l’ensemble des fonctions définies dans le programme : . varGlo=5 def maFonction1(): print (&quot;varGlo dans fonction1&quot;,varGlo) def maFonction2(): varGlo=4 print (&quot;varGlo dans fonction2&quot;,varGlo) print(&quot;Debut programme principal&quot;,varGlo) maFonction1() maFonction2() print(&quot;Fin programme principal&quot;,varGlo) . Afin de bien comprendre ce qui s&#39;est passé, revoyons l&#39;exécution de cette cellule au ralenti : . %%tutor varGlo=5 def maFonction1(): print (&quot;varGlo dans fonction1&quot;,varGlo) def maFonction2(): varGlo=4 print (&quot;varGlo dans fonction2&quot;,varGlo) print(&quot;Debut programme principal&quot;,varGlo) maFonction1() maFonction2() print(&quot;Fin programme principal&quot;,varGlo) . Vous constaterez dans l&#39;exemple ci-dessus que -varGlo est accessible en lecture dans maFonction1 -varGlo a pu être modifiée dans maFonction2 -les modifications de varGlo dans maFonction2 n&#39;ont pas été répercutées dans le programme principal ! . On peut avoir l&#39;impression en lisant le code que varGlo prend la valeur 4 dès que maFonction2 est exécutée. En réalité, maFonction2 va créer une variable locale de même nom que varGlo qui n&#39;aura d&#39;existance qu&#39;à l&#39;intérieur de la fonction. La variable globale varGlo créée au début du programme, elle, est inchangée. . Voila pourquoi il faut être prudent quant à l&#39;utilisation des variables globales. . Modifier une variable globale dans une fonction . Il est bien sûr possible de modifier le contenu d&#39;une variable globale à l&#39;intérieur d&#39;une fonction. Pour ce faire, on utilisera la commande python global pour indiquer à la fonction les variables globales accessibles en modification. . Etudiez l&#39;exemple suivant : . varGlo=5 def maFonction3(): global varGlo varGlo=4 maFonction3() . ## Que vaut varGlo après appel de maFonction3 ? ## indiquez votre réponse dans la variable réponse reponse = ... . assert varGlo == reponse . Exercice . Créer une variable globale nbCoups initialisée à 0 | Ecrire une fonction trouve prenant en paramètre un entier n | créant une variable locale inc qui est un entier aléatoire entre 1 et 10 | renvoyant True si $n$ est égal à inc, False sinon | le nombre de coups devra être incrémenté à chaque appel de la fonction | . | . Combien de coups vous a t-il fallu pour tomber sur le nombre choisi pr l&#39;ordinateur ? . from random import randint # YOUR CODE HERE raise NotImplementedError() . trouve(8) . nbCoups . nbCoups = 0 trouve(4) assert nbCoups == 1 . Les r&#233;f&#233;rences partag&#233;es : le cas des listes . Les listes Python sont des références, c’est à dire que écrire a = [(1,0,0),(0,1,0),(0,0,1)] ne signifie pas que a vaut [(1,0,0),(0,1,0),(0,0,1)] mais que a référence la liste [(1,0,0),(0,1,0),(0,0,1)], c&#39;est à dire contient un pointeur vers la zone mémoire qui contient cette liste. . La subtilité est que la commande b = a ne va pas duppliquer le contenu de la liste mais recopier une référence sur cette même liste. Si on modifie b, alors a sera également modifié. . L’examen des deux exemples suivant illustre ce concept. . a = [(1,0,0), (0,1,0), (0,0,1)] print (&quot;a=&quot;,a) b = a # On copie la référence, pas la liste b[0] = (1,1,0) # On modifie b print(&quot;b=&quot;,b) print(&quot;a=&quot;,a) # Ouuups !!! . Dans l&#39;exemple ci-dessus, la modification de $b$ entraîne sans qu&#39;on s&#39;y attende la modification de $a$ !! . Ce n&#39;est pas un bug de Python, c&#39;est normal quand on sait comment Python gère la mémoire. Revoyons cette séquence au ralenti en validant la cellule suivante: . %%tutor a = [(1,0,0), (0,1,0), (0,0,1)] print (&quot;a=&quot;,a) b = a # On copie la référence, pas la liste b[0] = (1,1,0) # On modifie b print(&quot;b=&quot;,b) print(&quot;a=&quot;,a) # Ouuups !!! . Vous le voyez, l&#39;outil python tutor est très pratique pour observer dans le détail comment Python gère la mémoire. N&#39;hésitez pas par la suite à l&#39;utiliser en ajoutant %%tutor en première ligne de cellule. . Pour suivre l&#39;utilisation de la mémoire, on peut aussi utiliser la commande id qui permet d&#39;obtenir l&#39;adresse mémoire de l&#39;objet référencé par une variable : . print(&quot;adresse de a&quot;,id(a)) print(&quot;adresse de b&quot;,id(b)) . Tout s&#39;explique !! a et b son un seul et même objet ! . Mais comment faire pour obtenir dans b une liste identique mais indépendante de a ? . a = [(1,0,0), (0,1,0),(0,0,1)] b = [(1,0,0), (0,1,0),(0,0,1)] print(&quot;adresse de a&quot;,id(a)) print(&quot;adresse de b&quot;,id(b)) . ah ! les adresses de a et de b sont différentes. Si je modifie b, a ne devrait pas être impacté. Vérifions le de suite ! . b[0] = (1,1,0) # On modifie b print(&quot;b=&quot;,b) print(&quot;a=&quot;,a) # Ouuuf !!! . On devra donc être prudent sur l’utilisation d’une affectation du type b=a surtout lorsqu’on travaille avec des listes ou des chaîne de caractères, des effets inattendus peuvent alors se produire. . # une erreur classique liste_desordre=[3,2,5,6,3,1] liste_ordre=liste_desordre liste_ordre.sort() print (&quot;Liste en ordre&quot;,liste_ordre) print (&quot;Liste de départ&quot;,liste_desordre) # oups . Et voici comment réaliser une véritable dupplication de notre liste : on utilise la méthode copy() . liste_desordre=[3,2,5,6,3,1] liste_ordre=liste_desordre.copy() liste_ordre.sort() print (&quot;Liste en ordre&quot;,liste_ordre) print (&quot;Liste de départ&quot;,liste_desordre) # ouf . Exercice . Ecrire une fonction double1 qui prend une liste de nombre en paramètre et qui multiplie chaque élément par 2. La fonction double1 renvoie la liste doublée. La liste de départ est modifiée par cette fonction. . Ecrire une fonction double2 qui prend une liste de nombre en paramètre et renvoie une liste contenant les doubles de tous les éléments de la liste passée en paramètre. La liste de départ n&#39;est pas modifiée par cette fonction. . Regardez la cellule de tests pour plus d&#39;informations si nécessaire . # YOUR CODE HERE raise NotImplementedError() . # Cellule de test liste = [3,4,5] assert double1(liste) ==[6,8,10] # double1 modifie la liste de départ assert liste == [6,8,10] liste = [3,4,5] assert double2(liste) ==[6,8,10] # double2 ne modifie pas la liste de départ assert liste == [3,4,5] . Le cas des cha&#238;nes . Lorsque l&#39;on manipule des variables contenant des chaînes de caractères, manipule t-on les références vers ces chaînes ou bien les contenus des chaînes de caractères ? . Le comportement des chaînes de caractères est-il identique à celui des listes ou non ? . En vous inspirant des manipulations faites listes mais avec des chaînes de caractères, tentez d&#39;apporter des réponses à ces questions. . # Faites vos tests ici . Lorsque on manipule des chaines de caractères, on manipule des références vers ces chaines. De ce point de vue, les chaînes se comporte comme les listes. . Observons si on peut avoir un effet de bord (modification non prévue d&#39;une variable) : . chaine = &#39;salut tout le monde&#39; autrechaine = chaine . autrechaine[2]=&quot;a&quot; . Il semble que les chaînes ne puissent pas être modifiées sur place. Ce sont des objets non mutables. Cela les distingue de listes. De ce point de vue, cela nous protège des effets de bord constatés sur les listes. . Oui mais qu&#39;en est-il de la concaténation ? en effet, on peut ajouter une chaine au bout d&#39;une chaine et en ce sens modifier notre chaine... regardons : . autrechaine += &quot; est moche&quot; print(autrechaine) print(chaine) . Tout va bien, autrechaine est modifiée mais sans effet non désiré sur chaine. Mais comment est-ce possible puisque on a modifié autrechaine ? . print(id(autrechaine)) print(id(chaine)) . Après ajout d&#39;une autre chaine au bout de la variable autrechaine, la variable autrechaine pointe sur un nouvel objet. Cela prouve que les chaines de caractères sont des objets non mutables contrairement aux listes. . Pas de crainte d&#39;effet de bord sur les chaines. . Conclusion . Il y a deux grands types d&#39;objets en python : . les objets mutables | les objets immuables | . Les objets mutables sont des objets qui acceptent d&#39;être modifiés sans avoir besoin d&#39;être recopiés - on parle alors de modification sur place. Exemples : les listes, les dictionnaires, les ensembles. . Les objets immuables sont des objets qui nécessitent d&#39;être recréés pour être modifiés. Exemple : les chaines de caractères ou les tuples. . Il faut être très prudent lors de la manipulation d&#39;objets mutables à cause du problème des références partagées qui peut occasionner des effets de bords non désirés : modification non prévue d&#39;autres variables que celle sur laquelle on agit. .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python4-Utilisation-avanceee-des-variables.html",
            "relUrl": "/python/isn/2020/03/07/Python4-Utilisation-avanceee-des-variables.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post19": {
            "title": "Les chaines de caracteres",
            "content": "chaine = &quot;Lycée Salvador Allende&quot; chaine[0] . Par contre, il est impossible de modifier une chaîne de caractères ! On dit alors qu&#39;il s&#39;agit d&#39;une liste non mutable : . chaine[1]= &quot;a&quot; . Si vous décidiez de lui ajouter des caractères en fin de chaîne à l&#39;aide d&#39;une concaténation du type suivant : . chaine = chaine+&quot; - Hérouville saint clair&quot; chaine . Remarque : Contrairement aux apparences, la chaine n&#39;a pas été modifiée puisque les chaines sont non mutables, une nouvelle chaine a été crée par concaténation des deux chaines placées autour du signe + . Il existe de nombreuses méthodes agissant sur les chaînes de caratères. Pour les voir, vous pouvez utiliser la fonction d&#39;autocompletion de Jupyter en tapant dans une cellule de code . chaine. . puis en pressant la touche TAB. N&#39;oubliez pas le . ! . Vous devriez voir la liste des méthodes disponibles : . . . . . . x.capitalize | x.isalnum | x.join | x.rsplit | . x.casefold | x.isalpha | x.ljust | x.rstrip | . x.center | x.isdecimal | x.lower | x.split | . x.count | x.isdigit | x.lstrip | x.splitlines | . x.encode | x.isidentifier | x.maketrans | x.startswith | . x.endswith | x.islower | x.partition | x.strip | . x.expandtabs | x.isnumeric | x.replace | x.swapcase | . x.find | x.isprintable | x.rfind | x.title | . x.format | x.isspace | x.rindex | x.translate | . x.format_map | x.istitle | x.rjust | x.upper | . x.index | x.isupper | x.rpartition | x.zfill | . chaine. . Inutile de toutes les connaître. Nous allons voir ici les fonctions les plus utiles. . Couper et joindre . La fonction split() permet de découper la chaîne de caractères qui lui est passée en paramètre suivant un ou des caractère(s) de séparation et renvoie une liste des chaînes découpées. Les caractères de séparation lui sont également passés en paramètre et, si ce n&#39;est pas le cas, ce sera le caractère espace qui sera utilisé : . chaine=&quot;Lycée Salvador Allende - Hérouville saint clair&quot; chaine.split() . chaine.split(&#39;-&#39;) . L&#39;opération inverse s&#39;appelle join(). Elle consiste a rendre une liste de chaînes de caractères pour former une chaîne en concaténant tous les éléments et en les assemblant à l&#39;aide d&#39;un caractère. . Cette méthode prend en paramètre une liste de caractères et s&#39;applique à une chaîne de caractères désignant le ou les caractère(s) de liaison : . liste = [&#39;Lycée Salvador Allende&#39;, &#39;Hérouville saint clair&#39;] &#39; - &#39;.join(liste) . Majuscule et minuscule . Deux autres méthodes standards peuvent être utiles: . lower() et upper() permettant respectivement de convertir les caractères d&#39;une chaîne en minuscules ou en majuscules. Attention, bien que parlant de conversion, ces méthodes ne modifient pas la chaîne de départ mais renvoient une nouvelle chaîne : . chaine.upper() . chaine.lower() . La fonction capitalize() permet de ne mettre en majuscule que la première lettre d&#39;une chaîne : . chaine.capitalize() . rechercher un caract&#232;re, une position etc... dans une cha&#238;ne. . La fonction len() permet, comme pour les listes, de connaîntre la longueur de la chaîne, c&#39;est à dire compter le nombre de caractères. | . chaine = &quot;Lycée Salvador Allende&quot; len(chaine) . La méthode count() permet de compter le nombre d&#39;occurrences d&#39;une sous chaîne dans une chaîne de caractères. Le premier paramètre est la chaîne dans laquelle effectuer la recherche et le second paramètre est la sous chaîne : | . chaine.count(&#39;a&#39;) . La méthode find() permet de trouver l&#39;indice de la première occurrence d&#39;une sous chaîne. Les paramètres sont les mêmes que pour la fonction count() En cas d&#39;échec, find() renvoie la valeur -1 ( 0 correspond à l&#39;indice du premier caractère): On utilisera rfind() pour la dernière ocurrence. | . chaine.find(&#39;a&#39;) . chaine.find(&#39;b&#39;) . chaine.rfind(&#39;a&#39;) . index() est identique à find() mais retourne une erreur en cas d&#39;échec | . chaine.index(&#39;a&#39;) . chaine.index(&#39;b&#39;) . La fonction replace() permet, comme son nom l&#39;indique, de remplacer une sous chaîne par une autre à l&#39;intérieur d&#39;une chaîne de caractères. Les paramètres sont, dans l&#39;ordre : la chaîne de caractères à modifier, la sous chaîne à remplacer, la sous chaîne de remplacement,et, éventuellement, le nombre maximum d&#39;occurrences à remplacer (si non spécifié, toutes les occurrences seront remplacées). | . chaine.replace(&#39;a&#39;,&#39;@&#39;) . et bien sûr, la variable chaine n&#39;est pas modifiée, c&#39;est une nouvelle chaine qui est renvoyée par cette méthode ! . chaine . Conversion cha&#238;ne &lt;-&gt; nombres . Il ne faut pas confondre les objets 12 et &quot;12&quot;. Le premier désigne un nombre, le second est une chaîne de caractère. Les comportements et les opérations sont différents. . 12 == &quot;12&quot; . 12+1 . &quot;12&quot;+&quot;1&quot; . Il peut être néanmoins possible de convertir un nombre en chaîne et réciproquement comme on va le voir sur les exemples ci-dessous . int(&quot;12&quot;) . str(12) . Comparaison de cha&#238;nes de caract&#232;res . De même qu&#39;il est possible de comparer deux nombres, on peut aussi comparer des chaines par rapport à l&#39;ordre lexicographique : . &quot;a&quot;&lt;&quot;b&quot; . &quot;a&quot;&lt;=&quot;r&quot;&lt;=&quot;z&quot; . &quot;a&quot;&lt;=&quot;R&quot;&lt;=&quot;z&quot; . &quot;toto&quot;&lt;&quot;titi&quot; . Tranches de cha&#238;nes . Le tranchage (slicing) fonctionne exactement comme pour les listes. Observez les exemples suivants. . chaine = &quot;Lycée Salvador Allende&quot; # obtenir la fin d&#39;une chaîne chaine[6:] . # obtenir le début d&#39;une chaîne chaine[:5] . # Un intervalle chaine[6:14] . Et avec des index négatifs ... . chaine[-1] . chaine[:-1] . # ce dernier exemple est très pratique pour renverser un itérable chaine[::-1] . Parcourir une cha&#238;ne de caract&#232;res . Une chaîne de raractère en Python rentre dans la catégorie des itérables au même titre que les listes. On retrouve donc les deux modes de parcours déjà rencontrés sur les listes, à savoir : . # Le parcours caractères par caractères : chaine = &quot;ISN&quot; for c in chaine: print(c) . # Le parcours par indice chaine = &quot;ISN&quot; for i in range(len(chaine)): print(chaine[i]) . Mise en pratique . Exercice 1 . Écrire une fonction nb_chiffres qui prend en paramètre une chaîne de caractère et qui renvoie le nombre de chiffres contenus dans la chaîne . def nb_chiffres(chaine): # YOUR CODE HERE raise NotImplementedError() . chaine = &quot;Lycée Allende - 14200 Hérouville&quot; assert nb_chiffres(chaine)==5 . Exercice 2 . Écrire une fonction is_email qui prend en paramètre une chaîne de caractère et renvoie True si celle-ci est une adresse mail. On va simplifier en considérant qu&#39;on a une adresse email si la chaîne possède les 2 propriétés suivantes : . Un seul caractère @ | Un seul caractère .(point) après @. | . def is_email(chaine): # YOUR CODE HERE raise NotImplementedError() . assert is_email(&quot;olivier.lecluse@monfai.com&quot;) assert not is_email(&quot;olivier.lecluse_AT_monfai.com&quot;) assert not is_email(&quot;olivier.lecluse@monfai&quot;) . Exercice 3 . Un nombre est un palindrome s&#39;il s&#39;écrit de la même manière de gauche à droite ou de droite à gauche. Exemple : 12521. . Ecrire une fonction est_palindrome prenant en paramètre un nombre et renvoyant True ou False selon que c&#39;est un palindrom ou non. . def est_palindrome(n): # YOUR CODE HERE raise NotImplementedError() . assert est_palindrome(12521) assert not est_palindrome(12520) . Exercice 4 . Ecrire une fonction somme_chiffres prenant un entier en paramètre et renvoyant la somme des chiffres de ce nombre. . somme_chiffres(125) renvoie 8 puisque 1+2+5=8 . def somme_chiffres(n): # YOUR CODE HERE raise NotImplementedError() . assert somme_chiffres(125)==8 .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python3-Les-chaines.html",
            "relUrl": "/python/isn/2020/03/07/Python3-Les-chaines.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post20": {
            "title": "Découverte des objets listes",
            "content": "Les listes sont des objets très importants en Python car elles permettent de stocker de multiples informations dans une seule variable. . Ci dessous, voici un exemple montrant la liste des entiers de 0 à 9. . list(range(10)) . Nous allons dans ce chapitre détailler ce qu&#39;est une liste, comment les manipuler et expliquer pourquoi elles sont si importantes en Informatique. . Manipulation de listes . Pr&#233;sentation du type list . Comme on peut le voir sur l&#39;exemple précédent, une liste en Python est un objet délimité par deux crochets et qui renferme un nombre fini d&#39;éléments de n&#39;importe quel type, ces éléments étant séparés par des virgules. . Voici quelques caractéristiques sur les listes . les éléments d&#39;une liste sont ordonnés : si on échange de place deux éléments différents d&#39;une liste, la liste est modifiée.&gt;- les éléments d&#39;une liste sont numérotés depuis 0&gt;- un même objet peut appparaître plusieurs fois dans une liste. | une liste peut contenir des éléments de type différents (nombres, chaines...) | . Premier_Exemple=[21,&quot;Bonjour&quot;,1+2,[1,2,3,1], 21 ] print(Premier_Exemple) print(Premier_Exemple[0]) . Premi&#232;res manipulations sur les listes . Créez une variable liste_carres contenant la liste les carrés des entiers de 1 à 10 . liste_carres = ... . assert 81 in liste_carres . Les éléments d&#39;une liste sont numérotés à partir de 0. On accède à un élément en utilisant une notation crochet : maListe[index]. . Observez l&#39;exemple et modifiez le pour accéder aux différents éléments de la liste_carres . Observez le message d&#39;erreur lorsque l&#39;index dépasse le nombre d&#39;éléments dans la liste ! . liste_carres[0] . liste_carres[11] . Il est possible de modifier un élément particulier d&#39;une liste. Il suffit de faire une affectation au moyen du signe = comme pour une simple variable. Observez plutôt : . liste_carres[1]=100 print(liste_carres) . On peut rechercher si un élément dans une liste. Par exemple pour savoir si 25 est un carré, on peut taper la ligne suivante. . Manipulez cette fonction en testant des nombres qui sont dans la liste et d&#39;autres qui n&#39;y sont pas. . On sera frappé par la similitude entre la syntaxe de python et le langage naturel. Cette simplicité est une des forces de Python. . 25 in liste_carres . On peut mettre deux listes bout à bout comme on le voit sur l&#39;exemple suivant. On remarque l&#39;utilisation naturelle du signe &#39;+&#39; pour ajouter deux listes bout à bout. . liste_carres=liste_carres + [121,144,169,196,225] print(liste_carres) . De même qu&#39;on possède l&#39;opération +, il existe aussi l&#39;opération * pour obtenir une liste formée de plusieurs fois la même liste. Je vous laisse découvrir le fonctionnement de cet opérateur dans la cellule ci-dessous : . 3*[1,2,4] . Pour savoir combien d&#39;éléments contient une liste, on peut utiliser la fonction len(). . Testez aussi les fonctions min() et max() sur la liste_carres. A quoi servent elles ? . len(liste_carres) . print(min(liste_carres)) print(max(liste_carres)) . Pour connaître la position d&#39;un objet dans une liste, on peut utiliser la méthode *.index(). Elle s&#39;utilise comme suit. Que se passe t-il si l&#39;objet recherché n&#39;appartient pas à la liste ? . liste_carres.index(81) . De la même manière, on peut compter le nombre d&#39;éléments dans une liste. Pour cela, on utilise la méthode .count() de manière similaire à .index(). Pour vous exercer, ajouter à liste_carres la liste [121,81,169,81] et comptez le nombre d&#39;occurences du nombre 81. . # A vous de jouer dans cette cellule liste_carres=... . Parcourir une liste . Il existe deux manières de parcourir une liste : . le parcours élément par élément | le parcours par index | . Dans les deux cas on utilisera une boucle pour. Observez les exemples suivants : . # Parcours élément par élément for elmt in liste_carres: print (&quot;ce nombre est un carré : &quot;,elmt) # Parcours par index longueur_liste = len(liste_carres) for indx in range(longueur_liste): print (&quot;ce nombre est aussi un carré : &quot;,liste_carres[indx]) . Dans le parcours par élément, la variable de boucle contient les différents éléments de la liste. Dans le second parcours par index, la variable de boucle est l&#39;index permettant d&#39;accéder à l&#39;élément. Il faut dans ce cas commencer par déterminer la longueur de la liste pour ne pas risquer un dépassement d&#39;index. . Exercice 1 . Ecrire une fonction etendue . prenant en paramètre une liste de nombres | renvoyant l&#39;étendue de cette liste à savoir l&#39;écart entre la plus grande valeur et la plus petite valeur | . | Ecrire une fonction somme . prenant en argument une liste | renvoyant la somme de tous les termes de la liste | . | Ecrire une fonction moyenne . prenant en paramètre une liste de nombres | renvoyant la valeur moyenne des nombres de la liste | . | # YOUR CODE HERE raise NotImplementedError() . La cellule de tests suivante doit s&#39;exécuter sans erreur . assert somme(list(range(1,30))) == 435 assert etendue([3,1,9,4,5])==8 assert moyenne([3,1,9,4,5])==4.4 . Modification d&#39;une liste . Pour modifier une liste, il suffit d&#39;effectuer une affectation à l&#39;un de ses éléments via son index. Observez les exemples ci-dessous. Que signifie l&#39;index -1 dans une liste ? . L=[[1,2,3],&quot;bonjour&quot;,3] print(&quot;Liste initiale &quot;,L) L[0]=[6,8] print(&quot;Premier élément modifié :&quot;,L) L[-1]=&quot;au revoir&quot; print(&quot;Qu&#39;est-ce qui a changé ?&quot;, L) L[0][-1]=9 print(&quot;On modifie le premier élément :&quot;,L) . Les m&#233;thodes sur les listes . Il existe encore d&#39;autres moyens de manipulation de listes. . Il existe en fait des fonctions intégrées à la structure de listes permettant d&#39;agir sur celles-ci : on les nomme méthodes et leur syntaxe générale est, étant donnée une liste $L$ : . $L.Methode()$, où $Methode()$ fait référence à l&#39;une des méthodes détaillée ci-dessous. . Il est à noter qu&#39;une fois la ligne $L.Methode()$ executée, la liste $L$ est, en général, transformée en sa liste modifiée. . Ces méthodes revoient à la programmation orientée objet de Python : les listes sont des objets qui sont manipulés, modifiés selon certains transformations et évoluent au grés de ces modifications. . Voici un petit catalogue des méthodes utiles. Vous retrouverez des méthodes déjà vues ci-dessus. . La m&#233;thode .append() . La syntaxe $L.append(objet)$ ajoute $objet$ à droite dans $L$ : . L=[1,2,3,4] L.append(5) print(L) # la liste initiale vient d&#39;être modifiée ! . La m&#233;thode .insert() . La syntaxe $L.insert(Indice,objet)$ insère $objet$ en place $Indice$ dans la liste $L$ et décale le reste des occurrences de $L$ à droite : . L=[&quot;Pomme&quot;,&quot;Poire&quot;,&quot;Banane&quot;] print(L) L.insert(1,&quot;Fraise&quot;) # vient prendre la place de &quot;Poire&quot; print(L) L.insert(-1,&quot;Ananas&quot;) # vient prendre la place de &quot;Banane&quot; print(L) . La m&#233;thode .remove() . La syntaxe $L.remove(objet)$ supprime de la liste la première occurrence égale à $objet$ dans la liste $L$. Si $objet$ n&#39;est pas présent dans $L$, cela produit un message d&#39;erreur. . M=[2,3,2,3,3,2,3] print(M) M.remove(2) print(M) # seul le premier &quot;2&quot; est supprimé ! M.remove(3) print(M) # seul le premier &quot;3&quot; est supprimé ! . La m&#233;thode .pop() . La syntaxe $L.pop([Indice])$ renvoie $L[Indice]$ et supprime l&#39;élément d&#39;index $Indice$ de la liste $L$. Il n&#39;est pas nécessaire que $Indice$ soit dans les bornes cycliques licites entre $-len(L)$ et $len(L)-1$, mais cela est quand même conseillé pour une meilleure lecture du script. . L=[2,3,2,2,1,2,&quot;mot&quot;,2,3] print(L) print(L.pop(6)) print(L) L.pop(-1) print(L) L.pop(3) print(L) . La m&#233;thode .index() . La syntaxe $L.index(objet)$ renvoie l&#39;index de la première occurrence d&#39;$objet$ dans $L$. La liste $L$ n&#39;est pas modifiée par cette méthode. Cela renvoie un message d&#39;erreur lorsque $objet$ ne figure pas dans la liste $L$. . Liste=[2,1,2,&quot;un mot&quot;,3,2,3,2] print(Liste) print(Liste.index(&quot;un mot&quot;)) print(Liste.index(3)) print(Liste) # liste non modifiée . La m&#233;thode .count() . La syntaxe $L.count(objet)$ renvoie le nombre d&#39;occurrences égales à $objet$ dans la liste $L$. Cele ne modifie pas la liste initiale. . Liste.count(2) . Tranches de listes . Etant donnée une liste $L$, la syntaxe $L[Indice$$Debut:Indice$$Fin:Pas]$ renvoie la sous-liste composée des termes $L[k]$, où l&#39;indice $k$ vaut successivement $Indice$$Debut$,$Indice$$Debut$+$Pas$, $Indice$$Debut$+2 $Pas$, etc. On s&#39;arrête avant d&#39;avoir atteint $Indice$$Fin$. Le dernier indice n&#39;&#39;est jamais inclus dans la sélection. . Il est à noter que $Pas$ peut être strictement négatif. Regardez attentivement les exemples suivants. N&#39;hésitez pas à les modifier pour observer l&#39;influence de chaque indice. . L=list(range(30)) # list() trasnforme un objet en liste print(&quot;affichage de toute la liste : &quot;,L) print(&quot;une liste du troisième au dixième terme :&quot;,L[2:10]) print(&quot;affichage de certains termes : &quot;, L[3:28:6]) print(&quot;affichage sans le premier terme :&quot;, L[1:]) print(&quot;affichage des cinq premiers termes :&quot;,L[:5]) print(&quot;la liste dans le sens inverse :&quot;,L[::-1]) . Exercice 2 : Simulation de lancer de d&#233; . Ecrire une fonction genere_liste prenant en paramètre un entier $n$ | renvoyant une liste de $n$ nombres aléatoires entre 1 et 6 | . | Ecrire une fonction frequence_6 prenant en paramètre une liste de nombres | renvoyant la fréquence d&#39;apparition du 6 | . | Indication : On pourra utiliser les commandes suivantes pour tirer un nombre aléatoire entre 1 et 6 : . from random import * # A mettre au début du programme randint(1,6) . from random import * # A mettre au début du programme # YOUR CODE HERE raise NotImplementedError() .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python2-Introduction-aux-listes.html",
            "relUrl": "/python/isn/2020/03/07/Python2-Introduction-aux-listes.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post21": {
            "title": "Algorithmique et Programmation",
            "content": "Premiers scripts . Nous allons commencer à rédiger des petits programmes Python. Bien entendu, ceux-ci seront au début complètement dépourvus d&#39;intérêt. Au fur et à mesure, les choses gagneront en consistance et en efficacité pour atteindre des problèmes plus complexes. . Les variables . Les variables permettent de stocker des valeurs. Elles sont un moyen de nommer les informations pour une utilisation dans un programme. Chaque variable a un nom ; un exemple de nom de variable que nous utiliserons est monNombre. Pour stocker de l&#39;information dans une variable, nous écrivons une commande en utilisant le signe égal (=) dans la manière suivante : . monNombre = 13 print(monNombre+1) . L&#39;instruction très utile &quot;a=a+1&quot; qui n&#39;a aucun sens mathématique est très utile en informatique : . a=3 a=a+1 print(a) print(A) # la casse (distinction entre majuscules et minuscules) est prise en compte . En première ligne, la valeur 3 est affectée dans la place mémoire &quot;a&quot;. En deuxième ligne, l&#39;ordinateut calcule &quot;a+1&quot; puis l&#39;affecte dans la place mémoire &quot;a&quot; : la variable &quot;a&quot; devient donc égale à 4. On vient d&#39;augmenter (on dit aussi incrémenter) la variable &quot;a&quot; d&#39;une unité. La dernière ligne confirme le fait que le langage machine différencie les lettres minuscules et majuscules, d&#39;où le message d&#39;erreur. . Regardez l&#39;exemple suivant. . a=5 b=3 b=2*b-a . Quelle est la valeur prise par la variable $b$? Répondez dans la cellule ci-dessous. Vous indiquerez votre réponse dans la variable $ma _reponse$. . # Complétez ci-dessous ma_reponse = ... # Test automatique de la réponse. # En cas d&#39;erreur, Python vous le fera savoir ! # Si c&#39;est bon, la cellule ne renverra rien assert ma_reponse == b . Complément : vous trouverez tout au long de ces classeurs ces commandes python assert. . assert permet de vérifier une condition. Si la condition est vraie, il ne provoque aucun retour. Si au contraire le résultat du test est faux, assert provoque un message d&#39;erreur Python (ce qu&#39;on appelle une exception). . Cela permet de vous autocontrôler : en validant ces cellules contenant le mot assert, vous pourrez vérifier par vous même que vous avez bien répondu. . Les diff&#233;rents types de variable . Les variables peuvent contenir différents types d&#39;informations. On dit qu&#39;elles sont de type : . int : entiers (ex : -2 ; 5) | float : décimal (ex -2.0 ; 2e6=2000000.0) | str : chaîne de caractère (ex &#39;Bonjour&#39; ; &quot;Autre exemple&quot; ; &quot;2+3&quot; ; &quot;5&quot;) | bool : Booléen : Vrai ou Faux. (ex : 2==3, False, 3&lt;4) | list : Tableau ou liste (ex : [1,&#39;toto&#39;, 2.0] ; [[1,2],[3,4]]) | . a = 5.2 b = 12 c = &quot;Je suis une chaîne de caractère&quot; d = [1, 4.2, &quot;je suis un tableau&quot;] e = type(b)==int # remarquez pour e la différence entre les opérateurs = et == . assert type(b) == int . Complétez les types dans la cellule suivante selon le modèle ci-dessus. Vous utiliserez les types énumérés plus haut. . assert type(a) == ... assert type(a/b) == ... assert type(c) == ... assert type(d) == ... assert type(e) == ... . Comme vous pouvez le voir, contrairement à d&#39;autres langages comme le langage C ou java, Python devine tout seul le type des variables. Il est inutile de lui préciser par avance. Cela est extrèmement pratique ! . Même si ce n&#39;est pas conseillé, on peut aussi changer de type en cours de route : . a=&quot;Je suis une chaîne&quot; type(a) . a=12 # et maintenenant je suis un nombre !!! type(a) . Affectations simultan&#233;es . Une application très classique de l&#39;affectation simultanée est l&#39;échange du contenu de deux variables . a, b = 32, 10 a . a, b = b, a # complétez les lignes ci-dessous avec les valeurs des variables a et b assert a == ... assert b == ... . L&#39;affectation multiple &quot;a, b = b, a&quot; permet en une seule ligne d&#39;échanger les contenus des variables a et b. Tentons maintenant d&#39;échanger deux variables a et b sans affectation multiple : . a=12 b=30 a=b b=a # complétez les lignes ci-dessous avec les valeurs des variables a et b assert a == ... assert b == ... . On a affecté à la variable b une valeur non numérique, mais une chaîne de caractère (entre guillemets). La troisième ligne confirme l&#39;affectation pour &quot;a&quot; et &quot;b&quot;. Cependant, la quatrième ligne efface de la mémoire la valeur de &quot;a&quot;, de sorte que &quot;a&quot; devient égal à &quot;b&quot;. L&#39;instruction &quot;b=a&quot; est alors inutile. . Pour contourner ce problème, il faut avoir recours à une mémoire temporaire : . a = 12 b = 30 memoire_temp=a a = b b = memoire_temp assert a == 30 assert b == 12 . L&#39;absence d&#39;erreurs à l&#39;exécution de la cellule montre que le contenu de $a$ et $b$ a bien été échangé . Les fonctions . Les fonctions permettent de décomposer un programme complexe en une série de sous-programmes plus simples. De plus, les fonctions sont réutilisables : si nous disposons d&#39;une fonction capable de calculer une racine carrée, par exemple, nous pouvons l&#39;utiliser un peu partout dans notre programme sans avoir à la réécrire à chaque fois (on parle de factorisation du code) . La notion de fonction en informatique est comparable à la notion de fonction en mathématiques. Si nous avons $y = 3x+2$, pour une valeur donnée de $x$, nous aurons une valeur de $y$. . Exemple : $x=4$ donc $y= 14$ ($y = 3.4+2=14$, attention ici le point correspond au signe &quot;multiplié&quot;). . La fonction en informatique est basée sur la même idée : Voici la syntaxe employée en Python pour définir une fonction : . def nom_de_la_fonction(parametre): instruction_1 instruction_2 return y suite programme . La fonction renvoie la valeur contenue dans la variable y. . ATTENTION : Notez bien la présence du décalage entre la première ligne et les lignes suivantes. Ce décalage est appelé indentation, l&#39;indentation permet de définir un bloc de code. Dans l&#39;exemple ci-dessus, l&#39;indentation nous permet de savoir que &quot;instruction_1&quot;, &quot;instruction_2&quot; et &quot;return y&quot; constituent un bloc de code, ce bloc correspond au contenu de la fonction. &quot;suite programme&quot; ne fait pas partie de la fonction, car il n&#39;est pas indenté. Pour indenter du code, il y a 2 solutions : mettre 4 espaces ou utiliser une tabulation. En Python il est conseillé d&#39;utiliser les 4 espaces, mais ce n&#39;est pas une obligation. Une chose est sûre, une fois que vous avez choisi une méthode, n&#39;en changé surtout pas au cours d&#39;un même programme ! . source : https://pixees.fr/informatiquelycee/n_site/nsi_prem_pythonbase.html . Dans l&#39;exemple suivant, vous constaterez la similitude entre la syntaxe python et l&#39;écriture mathématique . # Validez cette cellule pour définir la fonctionf def f(x): y=3*x-2 return y . # Validez cette cellule pour invoquer la fonction f (lancer l&#39;exécution du code contenu dans la fonction f) # La valeur 3 va alors prendre la place du paramètre x f(3) . Les fonctions jouent un rôle fondamental en informatique. Aucun programme n&#39;est écrit d&#39;un bloc. Imaginez un programme comme OpenOffice qui contient plusieurs centaines de milliers de lignes de codes écrites bout à bout sans structure... . Vous devrez prendre l&#39;habitude de concevoir vos propres fonctions pour répondre à un problème donné. . Plus tard, nous allons voir la notion d&#39;objet qui est apparu au début des années 80 et qui vient encore enrichir ce concept de fonction. Aujourd&#39;hui tous les langages modernes sont orientés Objet. La programmation par objet a permis l&#39;émergence de systèmes d&#39;exploitation offrant des interfaces graphiques évoluées (Linux, MacOs...). . Vous allez vous-même manipuler des objets quand vous allez découvrir la programmation d&#39;interfaces graphiques pour vos projets. . Instruction conditionnelle Si...Alors...Sinon . Observez le fonctionnement de la fonction ci-dessous : . def exemple2(age): if age &gt;= 18: return &quot;vous êtes majeur&quot; elif age &gt; 0: return &quot;vous êtes mineur&quot; else : return &quot;menteur !&quot; . Les clauses elif et else sont optionnelles pour la structure if. | Il est possible de mettre autant de elif que l&#39;on veut si on veut tester de multiples conditions sur une variable. | Il ne peut y avoir au plus qu&#39;une seule clause else dans une structure conditionnelle. | . Boucle pour . La syntaxe de la boucle pour est un peu particulière : On dit à une variable de parcourir un certain intervalle. . L&#39;intervalle en question est décrit par l&#39;instruction range(n). Les quelques exemples ci-dessous vous illustrent le fonctionnement de cette instruction. . L&#39;instruction print en python permet d&#39;afficher un texte à l&#39;écran. . for i in range(5): print(&quot;je répète 5 fois la même chose. Ici, i=&quot;,i) . Ce qu&#39;il faut retenir c&#39;est : . que la boucle for i in range(n) tournera n fois | que la variable i prendra les valeurs entières entre 0 et n-1 | . Importance du symbole &quot;:&quot; . Remarquez bien le : après le range. Cela marque le début d&#39;un bloc. . Un bloc en python se distingue par le décalage par rapport à la marge. Il permet de délimiter le début etr la fin du contenu de la boucle pour. En effet, contrairement à la calculatrice, il n&#39;y a par de mot clé end(TI) ou next (casio) pour signifier la fin de la boucle pour. . On retrouvera cette notion de bloc également pour les boucles tant que, les tests si... alors... sinon..., les définitions de fonction etc... . Soyez donc très attentif à la présence de ces : et au décalage de marge qui s&#39;en suit. . On peut paramétrer un peu l&#39;instruction range : . range(1,10) . Le compteur commencera à 1 et s&#39;arrêtera à 9 . Exemple : Expérimenter et expliquer les valeurs prises par la variable i dans la boucle . for i in range( 3,15,2) : . for i in range( 3,15,2) : print(i) . Dans la boucle pour, . la variable i est initialisée à 3 à 3 | la variable i augmente d&#39;un pas de 2 | la boucle s&#39;arrete quand i dépasse la valeur 15-1=14 | . Exercices . Ecrire une fonction somme qui calcule la somme des entiers jusqu&#39;à $n$ passé en paramètre. | def somme(n): # YOUR CODE HERE raise NotImplementedError() . assert somme(100) == 5050 . En mathématiques, on utilise la fonction factorielle d&#39;un nombre pour calculer le produit de tous les entiers non nuls entre 1 et ce nombre. Par exemple : | Factorielle 5 (que l&#39;on note 5!) se calcule par la formule : $5!=1 times 2 times 3 times 4 times 5=120$ . Ecrire une fonction factorielle prenant en argument un entier et retournant la factorielle de ce nombre. . def factorielle(n): # YOUR CODE HERE raise NotImplementedError() . # Testez votre fontion assert factorielle(5) == 120 . Vous avez vu en première l&#39;opérateur k parmi n noté ${n} choose {k}$ permettant de comptabiliser le nombre de chemins menant à $k$ succès dans une répétition de $n$ expériences Succès/Echec. . On peut montrer que ce nombre de chemins peut se calculer facilement au moyen de la fonction factorielle vu plus haut : ${n choose k }= dfrac{n!}{k!(n-k)!}$ . Ecrire une fonction coefbinom prenant en argument deux entiers $k$ et $n$ et retournant la valeur de $n choose k$. . On pourra faire appel à la fonction factorielle vue ci-dessus. . def coefbinom (k,n): # YOUR CODE HERE raise NotImplementedError() . # On teste la fonction assert coefbinom(2,4) == 6 . Vous voyez que des fonctions peuvent s&#39;appeler entre elles. Le code est ainsi plus concis et plus limpide. On évite les répétitions et on limite les erreurs. . Il est donc fortement conseillé de les utiliser le plus possible dans vos programmes et votre projet. . D&#39;une manière générale, quand vous allez chercher à écrire un programme pour réaliser une tache, avant d&#39;écrire la moindre ligne de code, vous allez réfléchir au découpage de votre tache en sous taches qui seront éxécutées chacune par une ou plusieurs fonctions. Une fois la spécification précise de ces fonctions réalisées, alors vous pourrez commencer à écrire ces fonctions, puis votre programme. . Boucle Tant que . Exécuter la fonction exemple ci-dessous. Quel est son rôle ? Remarquez la présence des : et le décalage de marge. . def exemple(): u=10 n=0 while u&lt;20: u = u+1.1 n = n+1 return n . # Invoquez la fonction exemple ci-dessous . A vous de jouer ... . Soit $(u_n)_{n in mathbb N}$ la suite définie par . $u_0=2$ | $u_{n+1}=0,2 times u_n+10$ | . Déterminer le plus petit rang $n$ pour lequel $u_n geqslant 12.49995$ . Pour cela, complétez la fonction seuil ci-dessous . prenant en paramètre une variable $s$ contenant le seuil à dépasser | renvoyant le rang $n$ à partir duquel le seuil $s$ est dépassé | . def seuil(s): # YOUR CODE HERE raise NotImplementedError() . La cellule suivante doit s&#39;exécuter sans erreur . assert seuil (12.49995) == 8 .",
            "url": "https://fastpages.fast.ai/python/isn/2020/03/07/Python1-Les_premiers_pas_en_python.html",
            "relUrl": "/python/isn/2020/03/07/Python1-Les_premiers_pas_en_python.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post22": {
            "title": "Le démineur",
            "content": "Un tableau &#224; deux dimensions . Nous savons qu&#39;il est possible de mettre dans des listes tout type d&#39;objets, et donc pourquoi pas... des listes ! Nous pouvons donc obtenir ainsi des tableaux à deux dimensions. L&#39;exemple suivant montre la création manuelle d&#39;un tableau 3x3. . grille=[[1, 2, 3],[4,5,6], [7,8,9]] grille[0][2] . Construction d&#39;une grille . Construire une ligne . Ecrire une fonction creer_ligne_0 . prenant en paramètre un nombre $n$ | renbvoyant une liste contenant $n$ fois la valeur 0 Conseils : | pour initialiser notre ligne, on pourra utiliser une liste vide [ ] | on pourra utiliser une boucle pour | on pourra utiliser la méthode append() qui permet d&#39;ajouter un élément à la fin d&#39;une liste | . def creer_ligne_0(n): # YOUR CODE HERE raise NotImplementedError() . Vérification : La cellule suivante doit s&#39;exécuter sans erreurs . assert creer_ligne_0(10) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . On souhaite à présent remplacer quelques 0 aléatoirement par des 1. Fixons la probabilité d&#39;avoir 1 à 0,2. . Voici comment mathématiquement nous pouvons obtenir 0 ou 1 avec une probabilité de 0,2 d&#39;avoir 1. Il s&#39;agit ici d&#39;exploiter le fait que la fonction random()+0.2 renvoie un nombre entre 0.2 et 1.2... . En validant la cellule ci-dessous plusieurs fois, vous devriez obtenir 1 de temps en temps. . from random import * p=0.2 print(int(random()+p)) . A présent, utilisez cette astuce de calcul pour créer une fonction creer_ligne . prenant en paramètres deux nombres $n$ et $p$ | renvoyant une liste de longueur $n$ formée de 0 et de 1 où 1 apparaît avec la probabilité $p$. | . from random import random def creer_ligne(n,p): # YOUR CODE HERE raise NotImplementedError() . Vérification : La cellule suivante doit s&#39;exécuter sans erreurs . assert 175&lt;=creer_ligne(1000,0.2).count(1)&lt;=225 . construire une grille . Une grille - ou un tableau à deux dimensions - est en réalité une liste de lignes. Chaque ligne est construite selon le même procédé que celui utilisé ci-dessus. . Pour construire notre grille, nous allons donc construire une liste de $n$ éléments mais au lieu de mettre 0 ou 1, nous mettrons une ligne que nous construirons à l&#39;aide de la fonction creer_ligne. . Ecrire une fonction creer_grille . prenant en paramètre un nombre $n$ et une probabilité $$ | renvoyant une grille $n times n$ où 1 apparaît avec une probabilité p L&#39;appel creer_grille(10,0.2) renverra quelque chose du genre : [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1]] . | . def creer_grille(n,p): # YOUR CODE HERE raise NotImplementedError() . Vérification : La cellule suivante doit afficher quelque chose ressemblant à ceci : . [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1]] . # Vérification : creer_grille(10,0.2) . Félicitations votre grille est créée ! . Jouer un coup . Créer une fonction jouer_coup . prenant en paramètre une grille, un indice de ligne et un indice de colone | renvoyant False si on est tombé sur une bombe | dans le cas contraire, un &quot;2&quot; sera placé à l&#39;emplacement joué et on renverra True . | Pour faire un test comportant un sinon ... si, on pourra utiliser la structure Python suivante : . if condition : bloc d&#39;instructions à réaliser si condition est vraie else : bloc d&#39;instructions à réaliser si aucune condition n&#39;est vraie . | l&#39;accès à l&#39;élément de la grille à la colonne c et la ligne l se fait par grille[l][c] . | . def jouer_coup(grille, ligne, col): # YOUR CODE HERE raise NotImplementedError() . Vérifiez en validant la cellule ci-dessous que des 2 ont bien été positionnés sur les cellules découvertes . grille = [[0,1],[1,0]] assert jouer_coup(grille,1,1) == True assert grille == [[0,1],[1,2]] assert jouer_coup(grille,0,1) == False . Nombre de cases libres . Ecrire une fonction cases_libres . prenant en paramètre une grille | renvoyant le nombre de cases libres (0) dans la grille. | . Une bombe ou un coup joué n&#39;est pas considéré comme case libre. . def cases_libres(grille): # YOUR CODE HERE raise NotImplementedError() . grille=[[0, 2, 0], [1, 0, 0], [0, 0, 0]] assert cases_libres(grille) == 7 . Nombre de bombes alentours . Ecrire une fonction bombes_autour . prenant en paramètre une grille, un indice de ligne et un indice de colone | renvoyant le nombre de bombes dans les cases adjacentes. | . Si une bombe est présente sur la case indiquée, celle-ci n&#39;est pas comptabilisée. . Attention aux indices afin de ne pas dépasser des limites de la grille ! Pour tester si un nombre est compris entre 2 valeurs, on pourra utiliser la syntaxe suivante : . if 0 &lt;= x &lt; n : blablabla . def bombes_autour(grille, ligne, col): # YOUR CODE HERE raise NotImplementedError() . grille=[[0, 0, 0], [1, 0, 0], [0, 0, 0]] assert bombes_autour(grille,2,2) == 0 assert bombes_autour(grille,1,1) == 1 . Afficher une grille . Ecrire une fonction afficher_grille . prenant en paramètre une grille | affichant la grille avec le format suivant : si une case a été découverte, on affiche le nombre de bombes alentours | si une case n&#39;a pas été découverte ou qu&#39;elle contient une bombe on affiche &quot;.&quot; | . | . Indication On pourra observer la cellule suivante afin pour voir comment afficher des informations avec print . Exemple : voici une grille simple et l&#39;affichage attendu . [[0, 2, 0], . 1 . [1, 2, 0], ==&gt; . 1 . [0, 0, 2]] . . 0 . print(&quot;Hello &quot;,end=&quot; &quot;) print(&quot;World&quot;) print(&quot;Sans le paramètre end, je retourne à la ligne&quot;) . def afficher_grille(grille): # YOUR CODE HERE raise NotImplementedError() . # Testez vous-même votre fonction sur l&#39;exemple donné grille = [[0, 2, 0], [1, 2, 0], [0, 0, 2]] afficher_grille(grille) . Jouer une partie . Ecrire une fonction jouer . qui prend en paramètres une grille, un indice de ligne et un indice de colonne | qui joue le coup indiqué et affiche la grille résultante | qui renvoie - -1 si on tombe sur une bombe - 0 si il ne reste plus de case à découvrir - le nombre de cases restant à découvrir (hors bombes) sinon . | . def jouer(grille,ligne, col): # YOUR CODE HERE raise NotImplementedError() . grille = [[0, 2, 0], [1, 2, 0], [0, 0, 2]] assert jouer(grille,0,0) == 4 assert jouer(grille, 1,0) == -1 . # Dérouler une partie grille = creer_grille(10, 0.2) jouer(grille,5,5) . jouer(grille,0,0) . jouer(grille,9,9) . grille .",
            "url": "https://fastpages.fast.ai/isn/miniprojet/2020/03/07/Le-demineur.html",
            "relUrl": "/isn/miniprojet/2020/03/07/Le-demineur.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post23": {
            "title": "Découverte de l'environnement Jupyter",
            "content": "Concr&#234;tement, comment &#231;a marche ? . Il y a deux type de cellules : . les cellules contenant du texte (Markdown, Headers) | les cellules contenant des instructions Python : In [ ] | . Vous pouvez à tout moment changer le type d&#39;une cellule grâce à la liste déroulante sur la barre d&#39;outils. Vous pouvez choisir entre : . code : la cellule contient alors des instructions Python qui seront interprétées | Markdown : la cellule contient alors du texte qui sera juste affiché | Heading x : la cellule s&#39;affichera comme un titre de section. | . Pour valider une cellule, appuyez sur la touche shift-enter ou bien cliquez sur le bouton &gt;| de la barre d&#39;icônes. . Regardez ci-dessous votre première ligne de code Python : Simple n&#39;est-ce pas ? . #collapse # Ceci est une cellule Python # Le code qu&#39;elle contient peut être exécuté # en tapant Shift+Entrée print(1+1) . . Et la p&#233;dagogie dans tout &#231;a ? . Grâce à l&#39;environnement Jupyter, l&#39;élève a sous les yeux les consignes du professeur ainsi que l&#39;outil lui permettant de les réaliser, le tout dans un environnement familier qu&#39;est le navigateur internet. Prenons un exemple d&#39;activité d&#39;algorithmique. . Coordonn&#233;es du milieu d&#39;un segment . On rappelle la formule : si $I$ est le milieu de $[AB]$, $$I= left( dfrac{x_A+x_B}{2}; dfrac{x_A+x_B}{2} right)$$ . Oui, je sais que vous le savez mais c&#39;est pour frimer avec l&#39;insertion de formules $ LaTeX$ dans Jupyter !! . Revenons aux choses sérieuses... . Compl&#233;ter l&#39;algorithme ci-dessous, &#233;crit en langage naturel . Pour modifier l&#39;algorithme, double-cliquez sur la cellule puis complétez les blancs. | Pour valider votre travail, tapez Shift+Entree | . Algorithme . Définir la fonction milieu qui prend 4 pamamètres : xA, yA, xB, yB xI prend la valeur ... yI prend la valeur ... retourner ... Fin de la fonction milieu Appeler la fonction ... avec les paramètres ... Stocker les résultats dans les variables xI et yI . # Codage de l&#39;algorithme en Python # Remplacez les ... par ce qui va bien :) def milieu(xA,yA,xB,yB): xI=... yI=... return ... xI,yI=milieu(...) (xI,yI) . Nous avons ainsi créé une fonction python. Cela nous permet d&#39;enrichir le langage python avec nos propres commandes. Maintenant, notre langage préféré sais calculer des milieux !! . Validez les cellules ci-dessous pour vous en convaincre. . milieu(1,2,5,6) . milieu(2,3,4,5) . Tiens c&#39;est bizarre, on dirait que c&#39;est le même milieu. Vérifions avec Python ! . Validez la cellule ci-dessous. . milieu(1,2,5,6)==milieu(2,3,4,5) . Remarquez la présence du symbole == pour tester l&#39;égalité de deux objets. Il ne faut pas le confondre avec le symbole = qui permet d&#39;affecter une valeur à une variable. . Compl&#233;tez : . Soient A(1;...) B(...;...) C(5;...) D(...;...) . Les segments [AC] et [BD] ont même milieu donc le quadrilatère ... est un ... . Ecrire une nouvelle fonction . En vous aidant de la démarche précédente, complétez la définition d&#39;une fonction estParallelogramme prenant en arguments les coordonnées de 4 points A, B, C et D puis retournant Vrai ou Faux selon que le quadrilatère ABCD est un parallélogramme ou pas. . Définir la fonction ... qui prend ... pamamètres : ... test prend la valeur ... retourner ... Fin de la fonction ... Entrées : Saisir ... Traitement : Appeler la fonction ... avec les paramètres ... Stocker le résultat dans la variable ... Sortie : Afficher ... . # Codez à présent cette fonction dans cette cellule . # On vérifie que cela marche. La cellule doit afficher True test=estParallelogramme(1,2,2,3,5,6,4,5) print(test) . Application . Utiliser la fonction que l&#39;on vient de définir pour dire si le quadrilatère ABCD est un parallélogramme : . $A left(-2;2 right)$ $B left( dfrac 2 5;- dfrac 6 5 right)$ $C left(4; dfrac 2 5 right)$ $D left( dfrac 9 5;3 right)$ . # A vous de jouer . Oui mais je veux voir la figure !! . Pas de panique, validez la cellule ci-dessous et vous pourrez facilement afficher des points ou des segments dans Jupyter. . %pylab inline ## Pour cette section on définit deux fonctions def trace_point(P,nom=&quot;&quot;): plot(P[0],P[1],&quot;ro&quot;) text(P[0]-(P[1]-P[0])/6,P[1], nom, color=&#39;r&#39;) def trace_segment(P,Q): plot([P[0],Q[0]],[P[1],Q[1]],&quot;b&quot;) . tadaaaaa... . # et on définit si on souhaite l&#39;échelle de notre repère xlim(-5,5) # On met ici l&#39;échelle sur l&#39;axe des abscisses ylim(-5,5) # et la l&#39;adresse sur l&#39;axe des ordonnées grid() A=(-2,2) B=(2/5,-6/5) C=(4,-1/5) D=(8/5,3) trace_point(A,&quot;A&quot;) trace_point(B,&quot;B&quot;) trace_point(C,&quot;C&quot;) trace_point(D,&quot;D&quot;) trace_segment(A,B) trace_segment(B,C) trace_segment(C,D) trace_segment(D,A) . C&#39;est g&#233;nial Python, je le veux je le veux !! . Python est un langage libre, gratuit et multiplateforme. Il sest disponible sur Window$, Linux, mac, ainsi que sur smartphones et tablettes Apple ou Androhideux. . Pour télécharger Python, vous pouvez vous rendre sur le site officiel http://python.org et choisir la version 3.6.2, mais cela n&#39;installera que l&#39;environnement très basique IDLE. . Pour avoir Python dans l&#39;environnement Jupyter que l&#39;on vient d&#39;utiliser, je recommande d&#39;installer la distribution clé en main Anaconda . Je veux Python mais je ne veux/peux rien installer sur mon ordinateur . Pas de panique, il existe des environnements prêts à l&#39;emploi disponible sur internet : . https://try.jupyter.org/ est un environnement jupyter complet prêt à l&#39;emploi mais attention, les classeurs réalisés sur ce site sont temporaires, c&#39;est à dire détruits à la déconnexion. Il faut donc bien penser à télécharger en local son travail avant de quitter... | https://repl.it/languages/python3 est un environnement entièrement en ligne du type IDLE donc console + éditeur de programme. Cela permet de tester rapidement un petit programme | http://pythontutor.com/ est un peu différent car il permet une exécution pas à pas des programme avec visualisation en temps réel du contenu des variables ce qui est un formidable outil pédagogique et de débuggage ! | .",
            "url": "https://fastpages.fast.ai/jupyter/formation/2020/03/07/Formation_Python_Fonctions.html",
            "relUrl": "/jupyter/formation/2020/03/07/Formation_Python_Fonctions.html",
            "date": " • Mar 7, 2020"
        }
        
    
  
    
        ,"post24": {
            "title": "Microsoft Word Example Post",
            "content": "When writing a blog post with Microsoft Word – the filename becomes the title. In this case the file name is “2020-01-01-Microsoft-Word-Example-Post.docx”. . There is minimal support for Word documents in fastpages compared to Jupyter notebooks. Some known limitations: . alt text in Word documents are not yet supported by fastpages, and will break links to images. . | You can only specify front matter for Word documents globally. See the README for more details. . | . For greater control over the content produced from Word documents, you will need to convert Word to markdown files manually. You can follow the steps in this blog post, which walk you through how to use pandoc to do the conversion. Note: If you wish to customize your Word generated blog post in markdown, make sure you delete your Word document from the _word directory so your markdown file doesn’t get overwritten! . If your primary method of writing blog posts is Word documents, and you plan on always manually editing Word generated markdown files, you are probably better off using fast_template instead of fastpages. . The material below is a reproduction of this blog post, and serves as an illustrative example. . Maintaining a healthy open source project can entail a huge amount of toil. Popular projects often have orders of magnitude more users and episodic contributors opening issues and PRs than core maintainers capable of handling these issues. . Consider this graphic prepared by the NumFOCUS foundation showing the number of maintainers for three widely used scientific computing projects: . . We can see that across these three projects, there is a very low ratio maintainers to users. Fixing this problem is not an easy task and likely requires innovative solutions to address the economics as well as tools. . Due to its recent momentum and popularity, Kubeflow suffers from a similar fate as illustrated by the growth of new issues opened: . . Source: “TensorFlow World 2019, Automating Your Developer Workflow With ML” . Coincidentally, while building out end to end machine learning examples for Kubeflow, we built two examples using publicly available GitHub data: GitHub Issue Summarization and Code Search. While these tutorials were useful for demonstrating components of Kubeflow, we realized that we could take this a step further and build concrete data products that reduce toil for maintainers. . This is why we started the project kubeflow/code-intelligence, with the goals of increasing project velocity and health using data driven tools. Below are two projects we are currently experimenting with : . Issue Label Bot: This is a bot that automatically labels GitHub issues using Machine Learning. This bot is a GitHub App that was originally built for Kubeflow but is now also used by several large open source projects. The current version of this bot only applies a very limited set of labels, however we are currently A/B testing new models that allow personalized labels. Here is a blog post discussing this project in more detail. . | Issue Triage GitHub Action: to compliment the Issue Label Bot, we created a GitHub Action that automatically adds / removes Issues to the Kubeflow project board tracking issues needing triage. . | Together these projects allow us to reduce the toil of triaging issues. The GitHub Action makes it much easier for the Kubeflow maintainers to track issues needing triage. With the label bot we have taken the first steps in using ML to replace human intervention. We plan on using features extracted by ML to automate more steps in the triage process to further reduce toil. . Building Solutions with GitHub Actions . One of the premises of Kubeflow is that a barrier to building data driven, ML powered solutions is getting models into production and integrated into a solution. In the case of building models to improve OSS project health, that often means integrating with GitHub where the project is hosted. . We are really excited by GitHub’s newly released feature GitHub Actions because we think it will make integrating ML with GitHub much easier. . For simple scripts, like the issue triage script, GitHub actions make it easy to automate executing the script in response to GitHub events without having to build and host a GitHub app. . To automate adding/removing issues needing triage to a Kanban board we wrote a simple python script that interfaces with GitHub’s GraphQL API to modify issues. . As we continue to iterate on ML Models to further reduce toil, GitHub Actions will make it easy to leverage Kubeflow to put our models into production faster. A number of prebuilt GitHub Actions make it easy to create Kubernetes resources in response to GitHub events. For example, we have created GitHub Actions to launch Argo Workflows. This means once we have a Kubernetes job or workflow to perform inference we can easily integrate the model with GitHub and have the full power of Kubeflow and Kubernetes (eg. GPUs). We expect this will allow us to iterate much faster compared to building and maintaining GitHub Apps. . Call To Action . We have a lot more work to do in order to achieve our goal of reducing the amount of toil involved in maintaining OSS projects. If your interested in helping out here’s a couple of issues to get started: . Help us create reports that pull and visualize key performance indicators (KPI). https://github.com/kubeflow/code-intelligence/issues/71 . We have defined our KPI here: issue #19 | . | Combine repo specific and non-repo specific label predictions: https://github.com/kubeflow/code-intelligence/issues/70 . | . In addition to the aforementioned issues we welcome contributions for these other issues in our repo. .",
            "url": "https://fastpages.fast.ai/2020/01/01/Microsoft-Word-Example-Post.html",
            "relUrl": "/2020/01/01/Microsoft-Word-Example-Post.html",
            "date": " • Jan 1, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://fastpages.fast.ai/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fastpages.fast.ai/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}