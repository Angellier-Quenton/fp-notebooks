---
keywords: fastai
description: Découverte de la notion d'objet
title: Programmation Orientée Objet
toc: true
badges: true
comments: false
categories: [python, ISN]
nb_path: _notebooks/2020-03-07-Python6 - Programmation Orientee Objet (POO) - Partie 1.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-03-07-Python6 - Programmation Orientee Objet (POO) - Partie 1.ipynb
-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Objets et POO sont au centre de la manière Python fonctionne. Vous n'êtes pas obligé d'utiliser la POO dans vos programmes - mais comprendre le concept est essentiel pour devenir plus qu'un débutant. Entre autres raisons parce que vous aurez besoin d'utiliser les classes et objets fournis par la librairie standard.</p>
<p>De plus, avant d'aborder la programmation d'interfaces graphiques qui utilisent abondamment les objet, des notions autour de la POO seront utiles.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Petit-historique">Petit historique<a class="anchor-link" href="#Petit-historique"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La programmation en tant que telle est une matière relativement récente. Etonnament la programmation orientée objet remonte aussi loin que les années 1960. <em>Simula</em> est considéré comme le premier langage de programmation orienté objet.</p>
<p>Les années 1970 voient les principes de la programmation par objet se développent et prennent forme au travers notamment du langage <em>Smalltalk</em></p>
<p>À partir des années 1980, commence l'effervescence des langages à objets : <em>Objective C</em> (début des années 1980, utilisé sur les plateformes Mac et iOS), <em>C++</em> (C with classes) en 1983 sont les plus célèbres.</p>
<p>Les années 1990 voient l'âge d'or de l'extension de la programmation par objet dans les différents secteurs du développement logiciel, notemment grâce à l'émergence des systèmes d'exploitation basés sur une interface graphique (MacOS, Linux, Windows) qui font appel abondamment aux principes de la POO.</p>
<p>Nous verrons sur le prochain classeur comment une interface graphique peut se programmer au moyens d'objets (fenêtre, boutons, textes, champs de saisie etc...).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Programmation-proc&#233;durale">Programmation proc&#233;durale<a class="anchor-link" href="#Programmation-proc&#233;durale"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La programmation procédurale est celle que vous avez utilisé jusqu'à maintenant : cela consiste à diviser votre programme en blocs réutilisables appelés fonctions.</p>
<p>Vous essayez autant que possible de garder votre code en blocs modulaires, en décidant de manière logique quel bloc est appelé. Cela demande moins d’effort pour visualiser ce que votre programme fait. Cela rend plus facile la maintenance de votre code – vous pouvez voir ce que fait une portion de code. Le fait d’améliorer une fonction (qui est réutilisée) peut améliorer la performance à plusieurs endroits dans votre programme.</p>
<p>Vous avez des variables, qui contiennent vos données, et des fonctions. Vous passez vos variables à vos fonctions – qui agissent sur elles et peut-être les modifient. L'inteaction entre les variables et les fonctions n'est pas toujours simple à gérer comme on l'a vu dans le classeur précédent ! ou bien une variable est locale et n'est pas visible des autres fonction, ou bien une variable est globale et toutes les fonctions sont suceptibles d'y avoir accès.</p>
<p>On touche ici aux limites de la programmation procédurale, lorsque le nombre de fonctions et de variables devient important.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mais-qu&#8217;est-ce-qu&#8217;un-Objet-?">Mais qu&#8217;est ce qu&#8217;un Objet ?<a class="anchor-link" href="#Mais-qu&#8217;est-ce-qu&#8217;un-Objet-?"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En Python les éléments de base de la programmation que nous avons rencontré comme les chaînes de caractères, ou les listes sont des objets. Ils possèdent des <em>propriétés</em> - variables qui stockent des valeurs - et des <em>méthodes</em> - fonctions qui agissent sur ces valeurs.</p>
<p>Voici un petit exemple d'objet qui vous est déjà familier :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">liste</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">liste</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">liste</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Ici nous avons fait appel à la <em>méthode</em> <strong>sort()</strong> de l'<em>objet</em> <strong>liste</strong> afin de trier notre liste.</p>
<p>Mais dans nos projets futurs, nous pouvons avoir envie de définir nos propres objets, c'est à dire d'enrichir la bibliothèque de types <strong><em>built-in</em></strong> standard de Python avec des objets que nous façonnerons selon nos besoins. C'est la qu'intervient la notion de classe.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Cr&#233;ation-d'une-classe">Cr&#233;ation d'une classe<a class="anchor-link" href="#Cr&#233;ation-d'une-classe"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En premier exemple, supposons que nous voulions travailler sur un logiciel de géométrie. Nous avons besoin d'un <strong><em>objet</em></strong> point qui est un nouveau type d'objet contenant deux informations :</p>
<ul>
<li>l'abscisse de notre point</li>
<li>l'ordonnée de notre point.</li>
</ul>
<p>Ces deux informations sont ce que nous appelons en POO des <strong><em>attributs</em></strong> ou des <strong><em>propriétés</em></strong>.</p>
<p>Assez de discours, créons notre classe :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">():</span>
    <span class="n">abscisse</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">ordonnee</span><span class="o">=</span><span class="mi">0</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Et c'est tout !!! nous avons créé une classe contenant deux <strong><em>propriétés</em></strong> une abscisse et une ordonnée toutes deux initialisées à 0.</p>
<p>Comment ça marche ?</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="n">Point</span><span class="o">.</span><span class="n">abscisse</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">Point</span><span class="o">.</span><span class="n">ordonnee</span><span class="p">)</span>
<span class="n">Point</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=</span><span class="mi">2</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">Point</span><span class="o">.</span><span class="n">abscisse</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Ca a l'air trè simple ! En réalité, nous allons vite être limité si nous n'utilisons que cette classe. En effet, nous créé un objet classe <em>Point</em> qui contient deux informations. Mais dans notre logiciel de géométrie, nous voulons créer plusieurs points !!</p>
<p>C'est le moment de parler de la notion <strong><em>d'instance</em></strong>. Une instance est un objet que nous créons en mémoire à partir d'une classe. Voici comment :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p1</span><span class="o">=</span><span class="n">Point</span><span class="p">()</span>
<span class="n">p2</span><span class="o">=</span><span class="n">Point</span><span class="p">()</span>
<span class="n">p1</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=</span><span class="mi">2</span>
<span class="n">p2</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">=</span><span class="mi">3</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">abscisse</span><span class="p">,</span><span class="n">p1</span><span class="o">.</span><span class="n">ordonnee</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">abscisse</span><span class="p">,</span><span class="n">p2</span><span class="o">.</span><span class="n">ordonnee</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Nous y voila ! J'ai donc à présent la possibilité de créer autant de points que je veux. Il faut bien distinguer la notion de <strong><em>classe</em></strong> et la notion <strong><em>d'instance</em></strong> :</p>
<ul>
<li>une <strong><em>classe</em></strong> peut être vue comme le prototype permettant de créer nos instances</li>
<li>les <strong><em>instances</em></strong> sont les véritables objets que nos manipulerons, créés à partir de notre <strong><em>prototype</em></strong>.</li>
</ul>
<p>Pour bien comprendre ce phénomène, prenons une comparaison avec le monde des contructeurs automobile : Lorsqu'un contructeur va sortir une nouvelle voiture, il ne va pas immédiatement produire en série plusieurs millions de véhicules. Il va tout d'abord élaborer un <strong><em>prototype</em></strong> :</p>
<ul>
<li>d'abord sur <strong><em>papier</em></strong>, il va dessiner sa nouvelle voiture, les formes, les équipements, chaque pièce de sa voiture etc...</li>
<li>ensuite il va réaliser une maquette, la tester en soufflerie pour affiner sa forme</li>
<li>enfin, il va réaliser un modèle fonctionnelle qu'il testera sur route : c'est le prototype.</li>
</ul>
<p>C'est ce travail que nous réaliserons lorsque nous construirons notre <strong><em>classe</em></strong>. Construire une classe c'est construire un <strong><em>prototype unique</em></strong>.</p>
<p>Une fois notre prototype terminé, notre constructeur va passer à la <strong><em>production en série</em></strong>. Il va créer des millions <strong><em>d'instances</em></strong> de notre prototype qui sont les voitures <strong><em>créées en série à partir de notre prototype</em></strong>. Chaque <strong><em>instance</em></strong> pourra être personnalisé à partir de notre prototype : en effet chaque nouvelle voiture possèdera sa propre couleur qui n'est pas forcément celle de notre prototype, possèdera des options spécifique (gps, toit ouvrant etc...).</p>
<p>Retenez donc cette comparaison :</p>
<ul>
<li>la <strong><em>classe</em></strong> correspond à notre <strong><em>prototype</em></strong></li>
<li>l'<strong><em>instance</em></strong> correspond à la voiture produite <strong><em>en série</em></strong> à partie de notre protptype (la classe).</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Notion-de-m&#233;thode">Notion de m&#233;thode<a class="anchor-link" href="#Notion-de-m&#233;thode"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Nous avons créé notre objet point qui se caractérise par deux <strong><em>propriétés</em></strong> : abscisse et ordonnée. Mais si ce n'était que cela, pourquoi ne pas utiliser un tuple ! Nous allons donc enrichir notre classe (le prototype servant de modèle pour créer nos points) en y ajoutant des fonctions uniques : les <strong><em>méthodes</em></strong>.</p>
<p>Nous nous intéressons par exemple à la distance séparant notre point de l'origine du repère. Nous souhaiterions que notre objet point possède une <strong><em>méthode</em></strong> pour nous renvoyer cette information. Une <strong><em>méthode</em></strong> n'est autre qu'une <strong><em>fonction</em></strong> intégrée à un objet. Voici comment procéder. Nous allons modifier notre <strong><em>classe</em></strong> :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span> <span class="c1"># On a besoin de la racine carrée !</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">():</span>
    <span class="n">abscisse</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">ordonnee</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">distanceAZero</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sqrt</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscisse</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Regardons le résultat :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p1</span><span class="o">=</span><span class="n">Point</span><span class="p">()</span>
<span class="n">p1</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=</span><span class="mi">3</span>
<span class="n">p1</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">=</span><span class="mi">4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">distanceAZero</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Et voila ! notre <strong><em>objet</em></strong> point commence à prendre tournure : il possède</p>
<ul>
<li>deux <strong><em>propriétés</em></strong> : <em>abscisse</em> et <em>ordonnee</em></li>
<li>une <strong><em>méthode</em></strong> : <em>distanceAZero()</em></li>
</ul>
<p>Cette méthode est une fonction encapsulée dans notre objet qui agit sur ses propriétés et effecture le travail demandé. Revenons sur la déclaration de cette méthode :</p>
<p>Une méthode se déclare comme une c=fonction classique à l'<em>intérieur de la classe</em> à ceci près qu'elle prend toujours <strong><em>en premier argument l'instance sur laquelle elle agit</em></strong>. Par convention, nous nommons cette instance <strong><em>self</em></strong>.</p>
<p>Nous voyons sur l'exemple de la <em>distanceAZero</em> l'avantage de disposer de cette information d'instance : nous voulons que la méthode agisse sur l'<strong><em>instance</em></strong>  depuis laquelle elle a été appelée et non sur les propriétés de la classe (le prototype). La variable <strong><em>self</em></strong> nous permettra de connaître l'instance sur laquelle nous travaillons.</p>
<p>Reste à décrire la syntaxe un peu étrange de cette fonction : Si <strong><em>self</em></strong>  est le premier argument, pourquoi ne le trouve t-on pas lors de l'appel de la fonction <em>distanceAZero()</em> ? Voici l'explication.</p>
<p>En réalité, nous devrions passer l'appel à la méthode de cette manière :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Point</span><span class="o">.</span><span class="n">distanceAZero</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Ainsi nous voyons bien que distanceAZero accepte bien l'instance sur laquelle elle agit en premier paramètre et que c'est une fonciton intégrée à la classe <strong><em>Point</em></strong>. Néanmoins cette syntaxe est très lourde ! Imaginez taper la ligne suivante à la place de</p>

<pre><code>liste.append(5)</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">liste</span><span class="p">,</span><span class="s1">&#39;autre syntaxe&#39;</span><span class="p">)</span>
<span class="c1"># Et pourtant cela foncitonne !</span>
<span class="nb">print</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Dans la pratique, une méthode sera toujours appelée depuis une instance et le premier paramètre sera omis puisque il est donnée justement par l'instance qui appelle. Syntaxiquement, les deux formes</p>

<pre><code>Point.distanceAZero(p1)
</code></pre>
<p>et</p>

<pre><code>p1.distanceAZero()

</code></pre>
<p>sont équivalentes. Nous utiliserons systématiquement la seconde forme.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="A-vous-de-jouer">A vous de jouer<a class="anchor-link" href="#A-vous-de-jouer"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vous allez enrichir la classe <strong><em>Point</em></strong> en ajoutant</p>
<ul>
<li>une propriété <strong><em>nom</em></strong> contenant le nom du point (par défaut 'A')</li>
<li>une méthode <strong><em>distance(p)</em></strong> qui <ul>
<li>affichera untexte du type "La distance AB=5" avec bien sur les vrais noms des points et la vraie distance</li>
<li>retournera la distance du point au point <em>p</em> passé en argument.</li>
</ul>
</li>
</ul>
<p>Attention, je rappelle qu'une méthode prend <strong><em>toujours</em></strong> en premier argument <strong><em>self</em></strong>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span> <span class="c1"># On a besoin de la racine carrée !</span>

<span class="c1"># Redéfinissez votre classe</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pour tester votre classe, validez la cellule suivante. La réponse doit être :</p>

<pre><code>La distance  AB = 5.0
Out[...]:5.0</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p1</span><span class="o">=</span><span class="n">Point</span><span class="p">()</span>
<span class="n">p1</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=</span><span class="mi">2</span>
<span class="n">p1</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">=</span><span class="mi">3</span>

<span class="n">p2</span><span class="o">=</span><span class="n">Point</span><span class="p">()</span>
<span class="n">p2</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=-</span><span class="mi">1</span>
<span class="n">p2</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">=</span><span class="mi">7</span>
<span class="n">p2</span><span class="o">.</span><span class="n">nom</span><span class="o">=</span><span class="s1">&#39;B&#39;</span>

<span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span><span class="o">==</span><span class="mf">5.0</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Surcharge-des-op&#233;rateurs">Surcharge des op&#233;rateurs<a class="anchor-link" href="#Surcharge-des-op&#233;rateurs"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On peut améliorer un peu le comportement de notre classe en initialisant de manière plus propre les différentes propriétés. En effet, pour le moment, pour créer un point avec le bon nom et les coordonnées souhaitées, nous avons besoin de 4 lignes !
    p1=Point()
    p1.abscisse=2
    p1.ordonnee=3
    p1.nom='P'</p>
<p>On peut faire beaucoup mieux en <strong><em>surchargeant</em></strong> la méthode <strong><em><strong>init()</strong></em></strong> qui est une méthode spéciale appelée automatiquement lors de la création d'ue instance. Cette méthode prend</p>
<ul>
<li>en premier paramètre <strong><em>self</em></strong> bien évidemment!</li>
<li>en paramètres optionnels, des paramètres passés à la classe lors de la création.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">nom</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abscisse</span><span class="o">=</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">=</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nom</span><span class="o">=</span><span class="n">nom</span>
    
    <span class="k">def</span> <span class="nf">distanceAZero</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sqrt</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscisse</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="n">d</span><span class="o">=</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">abscisse</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">abscisse</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordonnee</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">ordonnee</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;La distance &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nom</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">nom</span><span class="p">,</span><span class="s2">&quot;=&quot;</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Regardons comment créer notre point :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p1</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">p2</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="n">p1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>C'est quand même bien mieux ! Mais tout n'est pas parfait. Observez ce qui se passe si je veux afficher les coordonnées d'un point. Je peux avoir envie de faire cela :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="c1"># beark</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="A-vous-de-jouer">A vous de jouer<a class="anchor-link" href="#A-vous-de-jouer"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Il existe une autre méthode <em>magique</em> - en réalité, il y en a environs 80 - permettant de redéfinir le comportement des opérateurs intégrés à Python. Vous allez créer une méthode nommée <strong><em><strong>str()</strong></em></strong> qui</p>
<ul>
<li>ne prendra pas d'argument autre que <strong><em>self</em></strong> bien sur</li>
<li>retournera une chaîne de caractère du type "A(2;3)"</li>
</ul>
<p>Pour construire votre chaîne, vous pourrez utiliser la concaténation de chaines de caractères au moyen de l'opérateur +. Regardez l'exemple :</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span>
<span class="n">chaine</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;; etc...&quot;</span>
<span class="c1"># etc... vous voyez le principe</span>
<span class="nb">print</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># A vous de jouer</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Et voila la magie qui s&#39;opère !</span>

<span class="n">p1</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">p1</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;A(2;3)&#39;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Et voila, bien venue dans le monde merveilleux des objets.</p>
<p>En seconde partie, nous allons prendre un exemple plus sofistiqué sur les polynomes pour approfondir les notions que nous avons introduites dans ce classeur.</p>
<p>A bientôt !</p>

</div>
</div>
</div>
</div>
 

